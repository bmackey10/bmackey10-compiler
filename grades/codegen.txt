=====STUDENT TESTS=====
====Good Tests====
===[good0.bminor Input]===
main: function integer ()=
{
	return 0;
}
===[good0.bminor Output]===
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $0, %r10
MOVQ %r10, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET




return code: 0


===[good1.bminor Input]===
x: integer = 1;

main: function integer ()=
{
	return x;
}
===[good1.bminor Output]===

.data
.global x
x: .quad 1

.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ x, %r10
MOVQ %r10, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET




return code: 1


===[good10.bminor Input]===
f: function integer ( n:integer ) =
{
	i:integer;

	for(i=0;i<n;i++) { 

        if (i % 2 == 0 ) {
            print i, " is even\n";
        } else {
            print i, " is odd\n";
        }

	}

    return i;

}

main: function void () =
{
    
    print f(20), "\n";

}
===[good10.bminor Output]===
.global f
f:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $0, %r10
MOVQ %r10, -16(%rbp)
MOVQ $0, %r10
MOVQ %r10, -16(%rbp)
MOVQ %r10, %r11
.L0:
MOVQ -16(%rbp), %r10
MOVQ -8(%rbp), %r11
CMPQ %r11, %r10
JL .L2
MOVQ $0, %r11
JMP .L3
.L2:
MOVQ $1, %r11
.L3:
CMP $0, %r11
JE .L1
MOVQ -16(%rbp), %r10
MOVQ $2, %r11
MOVQ %r10, %rax
CQO
IDIVQ %r11
MOVQ %rdx, %r11
MOVQ $0, %r10
CMPQ %r10, %r11
JE .L4
MOVQ $0, %r10
JMP .L5
.L4:
MOVQ $1, %r10
.L5:
CMP $0, %r10
JE .L6
MOVQ -16(%rbp), %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s0: .string " is even\n"

.text
MOVQ $.s0, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L7
.L6:
MOVQ -16(%rbp), %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s1: .string " is odd\n"

.text
MOVQ $.s1, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L7
.L7:
MOVQ -16(%rbp), %r10
MOVQ %r10, %r11
INCQ %r10
MOVQ %r10, -16(%rbp)
JMP .L0
.L1:
MOVQ -16(%rbp), %r10
MOVQ %r10, %rax
JMP .f_epilogue

.f_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET

.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $20, %r12
MOVQ %r12, %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s2: .string "\n"

.text
MOVQ $.s2, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


0 is even
1 is odd
2 is even
3 is odd
4 is even
5 is odd
6 is even
7 is odd
8 is even
9 is odd
10 is even
11 is odd
12 is even
13 is odd
14 is even
15 is odd
16 is even
17 is odd
18 is even
19 is odd
20


return code: 1


===[good11.bminor Input]===
a: array [5] integer = {1, 2, 3, 4, 5};

main: function integer() = {

    i: integer;

    for (i = 0; i < 5; i++) {
        print a[i], "\n";
    }
}
===[good11.bminor Output]===

.data
.global a
a: .quad 1, 2, 3, 4, 5

.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $0, %r10
MOVQ %r10, -8(%rbp)
MOVQ $0, %r10
MOVQ %r10, -8(%rbp)
MOVQ %r10, %r11
.L0:
MOVQ -8(%rbp), %r10
MOVQ $5, %r11
CMPQ %r11, %r10
JL .L2
MOVQ $0, %r11
JMP .L3
.L2:
MOVQ $1, %r11
.L3:
CMP $0, %r11
JE .L1
MOVQ -8(%rbp), %r11
LEAQ a, %r12
MOVQ (%r12, %r11, 8), %r13
MOVQ %r13, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s0: .string "\n"

.text
MOVQ $.s0, %r12
MOVQ %r12, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ -8(%rbp), %r10
MOVQ %r10, %r12
INCQ %r10
MOVQ %r10, -8(%rbp)
JMP .L0
.L1:

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


1
2
3
4
5


return code: 1


===[good12.bminor Input]===
a: array [5] integer = {1, 2, 3, 4, 5};

main: function integer() = {

    i: integer;

    a[1] = -2;

    for (i = 0; i < 5; i++) {
        print a[i], "\n";
    }
}
===[good12.bminor Output]===

.data
.global a
a: .quad 1, 2, 3, 4, 5

.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $0, %r10
MOVQ %r10, -8(%rbp)
MOVQ $2, %r10
NEGQ %r10
MOVQ $1, %r12
LEAQ a, %r13
LEAQ (%r13, %r12, 8), %r11
MOVQ %r10, (%r11)
MOVQ %r10, %r11
MOVQ $0, %r10
MOVQ %r10, -8(%rbp)
MOVQ %r10, %r11
.L0:
MOVQ -8(%rbp), %r10
MOVQ $5, %r11
CMPQ %r11, %r10
JL .L2
MOVQ $0, %r11
JMP .L3
.L2:
MOVQ $1, %r11
.L3:
CMP $0, %r11
JE .L1
MOVQ -8(%rbp), %r11
LEAQ a, %r14
MOVQ (%r14, %r11, 8), %r15
MOVQ %r15, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s0: .string "\n"

.text
MOVQ $.s0, %r14
MOVQ %r14, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ -8(%rbp), %r10
MOVQ %r10, %r14
INCQ %r10
MOVQ %r10, -8(%rbp)
JMP .L0
.L1:

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


1
-2
3
4
5


return code: 1


===[good13.bminor Input]===
c: string = "hello";

main: function integer () = {

    a: char = 'a';
    b: char = 'b';
    d: string = "hello";
    e: string = c;
    f: char = 'a';
    g: char = b;

    if (c == d) {
        print "incorrect\n";
    } else {
        print "correct\n";
    }

    if (c == e) {
        print "correct\n";
    } else {
        print "incorrect\n";
    }

    if (a == b) {
        print "incorrect\n";
    } else {
        print "correct\n";
    }

    if (a == f) {
        print "correct\n";
    } else {
        print "incorrect\n";
    }

    if (b == g) {
        print "correct\n";
    } else {
        print "incorrect\n";
    }

}
===[good13.bminor Output]===

.data
.global c
.c: .string "hello"

.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $48, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $97, %r10
MOVQ %r10, -8(%rbp)
MOVQ $98, %r10
MOVQ %r10, -16(%rbp)

.data
.s0: .string "hello"

.text
MOVQ $.s0, %r10
MOVQ %r10, -24(%rbp)
MOVQ $.c, %r10
MOVQ %r10, -32(%rbp)
MOVQ $97, %r10
MOVQ %r10, -40(%rbp)
MOVQ -16(%rbp), %r10
MOVQ %r10, -48(%rbp)
MOVQ $.c, %r10
MOVQ -24(%rbp), %r11
CMPQ %r11, %r10
JE .L0
MOVQ $0, %r11
JMP .L1
.L0:
MOVQ $1, %r11
.L1:
CMP $0, %r11
JE .L2

.data
.s1: .string "incorrect\n"

.text
MOVQ $.s1, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L3
.L2:

.data
.s2: .string "correct\n"

.text
MOVQ $.s2, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L3
.L3:
MOVQ $.c, %r10
MOVQ -32(%rbp), %r11
CMPQ %r11, %r10
JE .L4
MOVQ $0, %r11
JMP .L5
.L4:
MOVQ $1, %r11
.L5:
CMP $0, %r11
JE .L6

.data
.s3: .string "correct\n"

.text
MOVQ $.s3, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L7
.L6:

.data
.s4: .string "incorrect\n"

.text
MOVQ $.s4, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L7
.L7:
MOVQ -8(%rbp), %r10
MOVQ -16(%rbp), %r11
CMPQ %r11, %r10
JE .L8
MOVQ $0, %r11
JMP .L9
.L8:
MOVQ $1, %r11
.L9:
CMP $0, %r11
JE .L10

.data
.s5: .string "incorrect\n"

.text
MOVQ $.s5, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L11
.L10:

.data
.s6: .string "correct\n"

.text
MOVQ $.s6, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L11
.L11:
MOVQ -8(%rbp), %r10
MOVQ -40(%rbp), %r11
CMPQ %r11, %r10
JE .L12
MOVQ $0, %r11
JMP .L13
.L12:
MOVQ $1, %r11
.L13:
CMP $0, %r11
JE .L14

.data
.s7: .string "correct\n"

.text
MOVQ $.s7, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L15
.L14:

.data
.s8: .string "incorrect\n"

.text
MOVQ $.s8, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L15
.L15:
MOVQ -16(%rbp), %r10
MOVQ -48(%rbp), %r11
CMPQ %r11, %r10
JE .L16
MOVQ $0, %r11
JMP .L17
.L16:
MOVQ $1, %r11
.L17:
CMP $0, %r11
JE .L18

.data
.s9: .string "correct\n"

.text
MOVQ $.s9, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L19
.L18:

.data
.s10: .string "incorrect\n"

.text
MOVQ $.s10, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L19
.L19:

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


correct
correct
correct
correct
correct


return code: 8


===[good14.bminor Input]===
x:integer = 1;

main: function integer () =
{
	for(;;)
	{
		if(x<20)
		{
			print x, "\n";
			x++;
		}
		else
		{
			return x;
		}
	}	
}
===[good14.bminor Output]===

.data
.global x
x: .quad 1

.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
.L0:
MOVQ $1, %r10
CMP $0, %r10
JE .L1
MOVQ x, %r10
MOVQ $20, %r11
CMPQ %r11, %r10
JL .L2
MOVQ $0, %r11
JMP .L3
.L2:
MOVQ $1, %r11
.L3:
CMP $0, %r11
JE .L4
MOVQ x, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s0: .string "\n"

.text
MOVQ $.s0, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ x, %r10
MOVQ %r10, %r11
INCQ %r10
MOVQ %r10, x
JMP .L5
.L4:
MOVQ x, %r10
MOVQ %r10, %rax
JMP .main_epilogue
JMP .L5
.L5:
JMP .L0
.L1:

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19


return code: 20


===[good15.bminor Input]===
a: array [5] integer = {1, 2, 3, 4, 5};

main: function integer() = {

    i: integer;

    for (i = 0; i < 5; i++) {
        print a[i], " ";
        a[i] = a[i] + 10;
        print a[i], "\n";
    }
}
===[good15.bminor Output]===

.data
.global a
a: .quad 1, 2, 3, 4, 5

.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $0, %r10
MOVQ %r10, -8(%rbp)
MOVQ $0, %r10
MOVQ %r10, -8(%rbp)
MOVQ %r10, %r11
.L0:
MOVQ -8(%rbp), %r10
MOVQ $5, %r11
CMPQ %r11, %r10
JL .L2
MOVQ $0, %r11
JMP .L3
.L2:
MOVQ $1, %r11
.L3:
CMP $0, %r11
JE .L1
MOVQ -8(%rbp), %r11
LEAQ a, %r12
MOVQ (%r12, %r11, 8), %r13
MOVQ %r13, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s0: .string " "

.text
MOVQ $.s0, %r12
MOVQ %r12, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ -8(%rbp), %r10
LEAQ a, %r12
MOVQ (%r12, %r10, 8), %r13
MOVQ $10, %r10
ADDQ %r13, %r10
MOVQ -8(%rbp), %r13
LEAQ a, %r14
LEAQ (%r14, %r13, 8), %r12
MOVQ %r10, (%r12)
MOVQ %r10, %r12
MOVQ -8(%rbp), %r12
LEAQ a, %r15
MOVQ (%r15, %r12, 8), %rbx
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s1: .string "\n"

.text
MOVQ $.s1, %r15
MOVQ %r15, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ -8(%rbp), %r10
MOVQ %r10, %r15
INCQ %r10
MOVQ %r10, -8(%rbp)
JMP .L0
.L1:

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


1 11
2 12
3 13
4 14
5 15


return code: 1


===[good16.bminor Input]===
func: function string ( hello_world: string) = {
    hello_world = "hello, brooke\n";
    return hello_world;
}

main: function integer () = {

    s: string = "hello, world\n";
    print func(s);

    return 0;
}
===[good16.bminor Output]===
.global func
func:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15

.data
.s0: .string "hello, brooke\n"

.text
MOVQ $.s0, %r10
MOVQ %r10, -8(%rbp)
MOVQ %r10, %r11
MOVQ -8(%rbp), %r10
MOVQ %r10, %rax
JMP .func_epilogue

.func_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET

.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15

.data
.s1: .string "hello, world\n"

.text
MOVQ $.s1, %r10
MOVQ %r10, -8(%rbp)
MOVQ -8(%rbp), %r12
MOVQ %r12, %rdi
PUSHQ %r10
PUSHQ %r11
CALL func
POPQ %r11
POPQ %r10
MOVQ %rax, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $0, %r10
MOVQ %r10, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


hello, brooke


return code: 0


===[good17.bminor Input]===
strcmp: function integer (s1: string, s1: string);

main: function integer () = {

    a: string = "hello";

    if (strcmp(a, "hello") == 0) {
        print "yes\n";
        return 0;
    } else {
        print "no\n";
        return 1;
    }

}
===[good17.bminor Output]===

.data
.global strcmp

.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15

.data
.s0: .string "hello"

.text
MOVQ $.s0, %r10
MOVQ %r10, -8(%rbp)
MOVQ -8(%rbp), %r11

.data
.s1: .string "hello"

.text
MOVQ $.s1, %r12
MOVQ %r11, %rdi
MOVQ %r12, %rsi
PUSHQ %r10
PUSHQ %r11
CALL strcmp
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $0, %r11
CMPQ %r11, %r10
JE .L0
MOVQ $0, %r11
JMP .L1
.L0:
MOVQ $1, %r11
.L1:
CMP $0, %r11
JE .L2

.data
.s2: .string "yes\n"

.text
MOVQ $.s2, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $0, %r10
MOVQ %r10, %rax
JMP .main_epilogue
JMP .L3
.L2:

.data
.s3: .string "no\n"

.text
MOVQ $.s3, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $1, %r10
MOVQ %r10, %rax
JMP .main_epilogue
JMP .L3
.L3:

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


yes


return code: 0


===[good18.bminor Input]===
main: function integer () = {
	return 4 + 10 / (-2 - (-4)) + (((2 + 3) * 4) - 1) % 3 * 2 - 2^3;
}
===[good18.bminor Output]===
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $4, %r10
MOVQ $10, %r11
MOVQ $2, %r12
NEGQ %r12
MOVQ $4, %r13
NEGQ %r13
SUBQ %r13, %r12
MOVQ %r11, %rax
CQO
IDIVQ %r12
MOVQ %rax, %r12
ADDQ %r10, %r12
MOVQ $2, %r10
MOVQ $3, %r11
ADDQ %r10, %r11
MOVQ $4, %r10
MOVQ %r11, %rax
IMULQ %r10
MOVQ %rax, %r10
MOVQ $1, %r11
SUBQ %r11, %r10
MOVQ $3, %r11
MOVQ %r10, %rax
CQO
IDIVQ %r11
MOVQ %rdx, %r11
MOVQ $2, %r10
MOVQ %r11, %rax
IMULQ %r10
MOVQ %rax, %r10
ADDQ %r12, %r10
MOVQ $2, %r12
MOVQ $3, %r13
MOVQ %r12, %rdi
MOVQ %r13, %rsi
PUSHQ %r10
PUSHQ %r11
CALL integer_power
POPQ %r11
POPQ %r10
MOVQ %rax, %r11
SUBQ %r11, %r10
MOVQ %r10, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET




return code: 3


===[good19.bminor Input]===
main: function integer () = {

    print "i think i have tested everything!\n";

    print "hi\nmaybe you'll see this!\n";

    print "\ttabs??\tyes\n";

    return 100;

}
===[good19.bminor Output]===
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15

.data
.s0: .string "i think i have tested everything!\n"

.text
MOVQ $.s0, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s1: .string "hi\nmaybe you'll see this!\n"

.text
MOVQ $.s1, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s2: .string "\ttabs??\tyes\n"

.text
MOVQ $.s2, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $100, %r10
MOVQ %r10, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


i think i have tested everything!
hi
maybe you'll see this!
	tabs??	yes


return code: 100


===[good2.bminor Input]===
main:function integer ()=
{
	return 1 + 1;
}
===[good2.bminor Output]===
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $1, %r10
MOVQ $1, %r11
ADDQ %r10, %r11
MOVQ %r11, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET




return code: 2


===[good3.bminor Input]===
main:function integer ()=
{
	return 4 - 1;
}
===[good3.bminor Output]===
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $4, %r10
MOVQ $1, %r11
SUBQ %r11, %r10
MOVQ %r10, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET




return code: 3


===[good4.bminor Input]===
main:function integer ()=
{
	return 2 * 2;
}
===[good4.bminor Output]===
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $2, %r10
MOVQ $2, %r11
MOVQ %r10, %rax
IMULQ %r11
MOVQ %rax, %r11
MOVQ %r11, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET




return code: 4


===[good5.bminor Input]===
main:function integer ()=
{
	return 10 / 2;
}
===[good5.bminor Output]===
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $10, %r10
MOVQ $2, %r11
MOVQ %r10, %rax
CQO
IDIVQ %r11
MOVQ %rax, %r11
MOVQ %r11, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET




return code: 5


===[good6.bminor Input]===
main:function integer ()=
{
	return 16 % 10;
}
===[good6.bminor Output]===
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $16, %r10
MOVQ $10, %r11
MOVQ %r10, %rax
CQO
IDIVQ %r11
MOVQ %rdx, %r11
MOVQ %r11, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET




return code: 6


===[good7.bminor Input]===
z: boolean = true;

main:function integer ()=
{
    x: boolean = true;
    y: boolean = false;

	if (x && z) {
        print "correct\n";
    } else {
        print "incorrect\n";
    }

    if (x && y) {
        print "incorrect\n";
    } else {
        print "correct\n";
    }

    if (x || y) {
        print "correct\n";
    } else {
        print "incorrect\n";
    }

    if (y || y) {
        print "incorrect\n";
    } else {
        print "correct\n";
    }

}
===[good7.bminor Output]===

.data
.global z
z: .quad 1

.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $16, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $1, %r10
MOVQ %r10, -8(%rbp)
MOVQ $0, %r10
MOVQ %r10, -16(%rbp)
MOVQ -8(%rbp), %r10
MOVQ z, %r11
ANDQ %r10, %r11
CMP $0, %r11
JE .L0

.data
.s0: .string "correct\n"

.text
MOVQ $.s0, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L1
.L0:

.data
.s1: .string "incorrect\n"

.text
MOVQ $.s1, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L1
.L1:
MOVQ -8(%rbp), %r10
MOVQ -16(%rbp), %r11
ANDQ %r10, %r11
CMP $0, %r11
JE .L2

.data
.s2: .string "incorrect\n"

.text
MOVQ $.s2, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L3
.L2:

.data
.s3: .string "correct\n"

.text
MOVQ $.s3, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L3
.L3:
MOVQ -8(%rbp), %r10
MOVQ -16(%rbp), %r11
ORQ %r10, %r11
CMP $0, %r11
JE .L4

.data
.s4: .string "correct\n"

.text
MOVQ $.s4, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L5
.L4:

.data
.s5: .string "incorrect\n"

.text
MOVQ $.s5, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L5
.L5:
MOVQ -16(%rbp), %r10
MOVQ -16(%rbp), %r11
ORQ %r10, %r11
CMP $0, %r11
JE .L6

.data
.s6: .string "incorrect\n"

.text
MOVQ $.s6, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L7
.L6:

.data
.s7: .string "correct\n"

.text
MOVQ $.s7, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L7
.L7:

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


correct
correct
correct
correct


return code: 8


===[good8.bminor Input]===
x: integer = 10;

main:function integer ()=
{
    v: integer = 2;
    w: integer = 10;
    y: integer = 100;
    z: integer = 2;

	if (x > z) {
        print "correct\n";
    } else {
        print "incorrect\n";
    }

    if (x >= w) {
        print "correct\n";
    } else {
        print "incorrect\n";
    }

    if (x < y) {
        print "correct\n";
    } else {
        print "incorrect\n";
    }

    if (w <= x) {
        print "correct\n";
    } else {
        print "incorrect\n";
    }

    if (v == z) {
        print "correct\n";
    } else {
        print "incorrect\n";
    }

    if (w != y) {
        print "correct\n";
    } else {
        print "incorrect\n";
    }

}
===[good8.bminor Output]===

.data
.global x
x: .quad 10

.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $32, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $2, %r10
MOVQ %r10, -8(%rbp)
MOVQ $10, %r10
MOVQ %r10, -16(%rbp)
MOVQ $100, %r10
MOVQ %r10, -24(%rbp)
MOVQ $2, %r10
MOVQ %r10, -32(%rbp)
MOVQ x, %r10
MOVQ -32(%rbp), %r11
CMPQ %r11, %r10
JG .L0
MOVQ $0, %r11
JMP .L1
.L0:
MOVQ $1, %r11
.L1:
CMP $0, %r11
JE .L2

.data
.s0: .string "correct\n"

.text
MOVQ $.s0, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L3
.L2:

.data
.s1: .string "incorrect\n"

.text
MOVQ $.s1, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L3
.L3:
MOVQ x, %r10
MOVQ -16(%rbp), %r11
CMPQ %r11, %r10
JGE .L4
MOVQ $0, %r11
JMP .L5
.L4:
MOVQ $1, %r11
.L5:
CMP $0, %r11
JE .L6

.data
.s2: .string "correct\n"

.text
MOVQ $.s2, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L7
.L6:

.data
.s3: .string "incorrect\n"

.text
MOVQ $.s3, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L7
.L7:
MOVQ x, %r10
MOVQ -24(%rbp), %r11
CMPQ %r11, %r10
JL .L8
MOVQ $0, %r11
JMP .L9
.L8:
MOVQ $1, %r11
.L9:
CMP $0, %r11
JE .L10

.data
.s4: .string "correct\n"

.text
MOVQ $.s4, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L11
.L10:

.data
.s5: .string "incorrect\n"

.text
MOVQ $.s5, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L11
.L11:
MOVQ -16(%rbp), %r10
MOVQ x, %r11
CMPQ %r11, %r10
JLE .L12
MOVQ $0, %r11
JMP .L13
.L12:
MOVQ $1, %r11
.L13:
CMP $0, %r11
JE .L14

.data
.s6: .string "correct\n"

.text
MOVQ $.s6, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L15
.L14:

.data
.s7: .string "incorrect\n"

.text
MOVQ $.s7, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L15
.L15:
MOVQ -8(%rbp), %r10
MOVQ -32(%rbp), %r11
CMPQ %r11, %r10
JE .L16
MOVQ $0, %r11
JMP .L17
.L16:
MOVQ $1, %r11
.L17:
CMP $0, %r11
JE .L18

.data
.s8: .string "correct\n"

.text
MOVQ $.s8, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L19
.L18:

.data
.s9: .string "incorrect\n"

.text
MOVQ $.s9, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L19
.L19:
MOVQ -16(%rbp), %r10
MOVQ -24(%rbp), %r11
CMPQ %r11, %r10
JNE .L20
MOVQ $0, %r11
JMP .L21
.L20:
MOVQ $1, %r11
.L21:
CMP $0, %r11
JE .L22

.data
.s10: .string "correct\n"

.text
MOVQ $.s10, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L23
.L22:

.data
.s11: .string "incorrect\n"

.text
MOVQ $.s11, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L23
.L23:

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


correct
correct
correct
correct
correct
correct


return code: 8


===[good9.bminor Input]===
x: integer = 5;
function_call: function string (num: integer);

main:function integer ()=
{

    y: integer = 15;

    print function_call(x), "\n";
    print function_call(y), "\n";

    return x * y;
}

function_call: function string (num: integer) = 
{

    if (num < 10) {
        return "small";
    } else {
        return "big";
    }

}
===[good9.bminor Output]===

.data
.global x
x: .quad 5
.global function_call

.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $15, %r10
MOVQ %r10, -8(%rbp)
MOVQ x, %r12
MOVQ %r12, %rdi
PUSHQ %r10
PUSHQ %r11
CALL function_call
POPQ %r11
POPQ %r10
MOVQ %rax, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s0: .string "\n"

.text
MOVQ $.s0, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ -8(%rbp), %r12
MOVQ %r12, %rdi
PUSHQ %r10
PUSHQ %r11
CALL function_call
POPQ %r11
POPQ %r10
MOVQ %rax, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s1: .string "\n"

.text
MOVQ $.s1, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ x, %r10
MOVQ -8(%rbp), %r11
MOVQ %r10, %rax
IMULQ %r11
MOVQ %rax, %r11
MOVQ %r11, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET

.global function_call
function_call:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ -8(%rbp), %r10
MOVQ $10, %r11
CMPQ %r11, %r10
JL .L0
MOVQ $0, %r11
JMP .L1
.L0:
MOVQ $1, %r11
.L1:
CMP $0, %r11
JE .L2

.data
.s2: .string "small"

.text
MOVQ $.s2, %r10
MOVQ %r10, %rax
JMP .function_call_epilogue
JMP .L3
.L2:

.data
.s3: .string "big"

.text
MOVQ $.s3, %r10
MOVQ %r10, %rax
JMP .function_call_epilogue
JMP .L3
.L3:

.function_call_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


small
big


return code: 75


====Bad Tests====
=====HIDDEN TESTS=====
====Good Tests====
===[good1.bminor Input]===
strlen: function integer(s: string);
f: function integer(i: integer);

main: function integer () = {
	if (f(strlen("hi")) > strlen("there")) {print "no\n";}
	if (f(f(strlen("hi"))) > strlen("there")) print "ok\n";

	return 0;
}

f: function integer(i: integer) = {
	return i*2;
}

===[good1.bminor Output]===

.data
.global strlen
.global f

.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15

.data
.s0: .string "hi"

.text
MOVQ $.s0, %r12
MOVQ %r12, %rdi
PUSHQ %r10
PUSHQ %r11
CALL strlen
POPQ %r11
POPQ %r10
MOVQ %rax, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s1: .string "there"

.text
MOVQ $.s1, %r12
MOVQ %r12, %rdi
PUSHQ %r10
PUSHQ %r11
CALL strlen
POPQ %r11
POPQ %r10
MOVQ %rax, %r11
CMPQ %r11, %r10
JG .L0
MOVQ $0, %r11
JMP .L1
.L0:
MOVQ $1, %r11
.L1:
CMP $0, %r11
JE .L2

.data
.s2: .string "no\n"

.text
MOVQ $.s2, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L3
.L2:
JMP .L3
.L3:

.data
.s3: .string "hi"

.text
MOVQ $.s3, %r13
MOVQ %r13, %rdi
PUSHQ %r10
PUSHQ %r11
CALL strlen
POPQ %r11
POPQ %r10
MOVQ %rax, %r12
MOVQ %r12, %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s4: .string "there"

.text
MOVQ $.s4, %r12
MOVQ %r12, %rdi
PUSHQ %r10
PUSHQ %r11
CALL strlen
POPQ %r11
POPQ %r10
MOVQ %rax, %r11
CMPQ %r11, %r10
JG .L4
MOVQ $0, %r11
JMP .L5
.L4:
MOVQ $1, %r11
.L5:
CMP $0, %r11
JE .L6

.data
.s5: .string "ok\n"

.text
MOVQ $.s5, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L7
.L6:
JMP .L7
.L7:
MOVQ $0, %r10
MOVQ %r10, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET

.global f
f:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ -8(%rbp), %r10
MOVQ $2, %r11
MOVQ %r10, %rax
IMULQ %r11
MOVQ %rax, %r11
MOVQ %r11, %rax
JMP .f_epilogue

.f_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


ok


return code: 0


===[good10.bminor Input]===
w: string = "no";

f: function void (s: string) = {
	{
		w: string = "ok";
		print w, "\n";
		w = "bad!\n";
	}
	print s, ' ', w;
	print " ";
	s = "changed\n";
	print s;
}

main:function integer ()= {
	s: string = "good";
	f(s);
	print s;

	return 0;
}

===[good10.bminor Output]===

.data
.global w
.w: .string "no"

.text
.global f
f:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15

.data
.s0: .string "ok"

.text
MOVQ $.s0, %r10
MOVQ %r10, -16(%rbp)
MOVQ -16(%rbp), %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s1: .string "\n"

.text
MOVQ $.s1, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s2: .string "bad!\n"

.text
MOVQ $.s2, %r10
MOVQ %r10, -16(%rbp)
MOVQ %r10, %r11
MOVQ -8(%rbp), %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $32, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_character
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $.w, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s3: .string " "

.text
MOVQ $.s3, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s4: .string "changed\n"

.text
MOVQ $.s4, %r10
MOVQ %r10, -8(%rbp)
MOVQ %r10, %r11
MOVQ -8(%rbp), %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.f_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET

.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15

.data
.s5: .string "good"

.text
MOVQ $.s5, %r10
MOVQ %r10, -8(%rbp)
MOVQ -8(%rbp), %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ -8(%rbp), %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $0, %r10
MOVQ %r10, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


ok
good no changed
good

return code: 0


===[good11.bminor Input]===
main: function integer () = {
	x: integer = 20;
	y: integer = x;
	{
		x: integer = 10;
		y = y + x;
	}

	{
		{
			y = y + x;
			x: integer = 2;
			y = y + x;
		}
		y = y + x;
		x: integer = 3;
		y = y + x;
	}
	return y + x;
}

===[good11.bminor Output]===
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $40, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $20, %r10
MOVQ %r10, -8(%rbp)
MOVQ -8(%rbp), %r10
MOVQ %r10, -16(%rbp)
MOVQ $10, %r10
MOVQ %r10, -24(%rbp)
MOVQ -16(%rbp), %r10
MOVQ -24(%rbp), %r11
ADDQ %r10, %r11
MOVQ %r11, -16(%rbp)
MOVQ %r11, %r10
MOVQ -16(%rbp), %r10
MOVQ -8(%rbp), %r11
ADDQ %r10, %r11
MOVQ %r11, -16(%rbp)
MOVQ %r11, %r10
MOVQ $2, %r10
MOVQ %r10, -32(%rbp)
MOVQ -16(%rbp), %r10
MOVQ -32(%rbp), %r11
ADDQ %r10, %r11
MOVQ %r11, -16(%rbp)
MOVQ %r11, %r10
MOVQ -16(%rbp), %r10
MOVQ -8(%rbp), %r11
ADDQ %r10, %r11
MOVQ %r11, -16(%rbp)
MOVQ %r11, %r10
MOVQ $3, %r10
MOVQ %r10, -40(%rbp)
MOVQ -16(%rbp), %r10
MOVQ -40(%rbp), %r11
ADDQ %r10, %r11
MOVQ %r11, -16(%rbp)
MOVQ %r11, %r10
MOVQ -16(%rbp), %r10
MOVQ -8(%rbp), %r11
ADDQ %r10, %r11
MOVQ %r11, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET




return code: 95


===[good13.bminor Input]===
foo_epilogue: function integer () = {
	return 2;
}

foo: function integer ();

main: function integer () = {
	return foo() * 11;
}

main_epilogue: function integer () = {
	return foo_epilogue() + 3;
}

foo: function integer () = {
	return main_epilogue() - 1;
}

===[good13.bminor Output]===
.global foo_epilogue
foo_epilogue:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $2, %r10
MOVQ %r10, %rax
JMP .foo_epilogue_epilogue

.foo_epilogue_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


.data
.global foo

.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
PUSHQ %r10
PUSHQ %r11
CALL foo
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $11, %r11
MOVQ %r10, %rax
IMULQ %r11
MOVQ %rax, %r11
MOVQ %r11, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET

.global main_epilogue
main_epilogue:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
PUSHQ %r10
PUSHQ %r11
CALL foo_epilogue
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $3, %r11
ADDQ %r10, %r11
MOVQ %r11, %rax
JMP .main_epilogue_epilogue

.main_epilogue_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET

.global foo
foo:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
PUSHQ %r10
PUSHQ %r11
CALL main_epilogue
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $1, %r11
SUBQ %r11, %r10
MOVQ %r10, %rax
JMP .foo_epilogue

.foo_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET




return code: 44


===[good12.bminor Input]===
main: function integer () = {
	return 4 + 9 / (-2 - (-5)) + (((2 + 1) * 4) - 1) % 3 * 7 - 8;
}

===[good12.bminor Output]===
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $4, %r10
MOVQ $9, %r11
MOVQ $2, %r12
NEGQ %r12
MOVQ $5, %r13
NEGQ %r13
SUBQ %r13, %r12
MOVQ %r11, %rax
CQO
IDIVQ %r12
MOVQ %rax, %r12
ADDQ %r10, %r12
MOVQ $2, %r10
MOVQ $1, %r11
ADDQ %r10, %r11
MOVQ $4, %r10
MOVQ %r11, %rax
IMULQ %r10
MOVQ %rax, %r10
MOVQ $1, %r11
SUBQ %r11, %r10
MOVQ $3, %r11
MOVQ %r10, %rax
CQO
IDIVQ %r11
MOVQ %rdx, %r11
MOVQ $7, %r10
MOVQ %r11, %rax
IMULQ %r10
MOVQ %rax, %r10
ADDQ %r12, %r10
MOVQ $8, %r11
SUBQ %r11, %r10
MOVQ %r10, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET




return code: 13


===[good15.bminor Input]===
// https://piazza.com/class/jziupd2lzpm7cy?cid=179

strdup: function string (s: string);

main: function integer () = {
	a: string = "sssss";
	b: string = strdup(a);
	if (a==b) return 22; else return 11;
}

===[good15.bminor Output]===

.data
.global strdup

.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $16, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15

.data
.s0: .string "sssss"

.text
MOVQ $.s0, %r10
MOVQ %r10, -8(%rbp)
MOVQ -8(%rbp), %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL strdup
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ %r10, -16(%rbp)
MOVQ -8(%rbp), %r10
MOVQ -16(%rbp), %r11
CMPQ %r11, %r10
JE .L0
MOVQ $0, %r11
JMP .L1
.L0:
MOVQ $1, %r11
.L1:
CMP $0, %r11
JE .L2
MOVQ $22, %r10
MOVQ %r10, %rax
JMP .main_epilogue
JMP .L3
.L2:
MOVQ $11, %r10
MOVQ %r10, %rax
JMP .main_epilogue
JMP .L3
.L3:

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET




return code: 11


===[good17.bminor Input]===
a1: integer;
a2: integer = 111;
a3: boolean = false;

A: function integer() = {
	if (a3) return a1 * a2;
	a2: integer = 3;
	if (!!!a3) return a1 + a2;
	return 0;
}

main: function integer() = { return A(); }

===[good17.bminor Output]===

.data
.global a1
a1: .quad 0
.global a2
a2: .quad 111
.global a3
a3: .quad 0

.text
.global A
A:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ a3, %r10
CMP $0, %r10
JE .L0
MOVQ a1, %r10
MOVQ a2, %r11
MOVQ %r10, %rax
IMULQ %r11
MOVQ %rax, %r11
MOVQ %r11, %rax
JMP .A_epilogue
JMP .L1
.L0:
JMP .L1
.L1:
MOVQ $3, %r10
MOVQ %r10, -8(%rbp)
MOVQ a3, %r10
NOTQ %r10
NOTQ %r10
NOTQ %r10
CMP $0, %r10
JE .L2
MOVQ a1, %r10
MOVQ -8(%rbp), %r11
ADDQ %r10, %r11
MOVQ %r11, %rax
JMP .A_epilogue
JMP .L3
.L2:
JMP .L3
.L3:
MOVQ $0, %r10
MOVQ %r10, %rax
JMP .A_epilogue

.A_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET

.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
PUSHQ %r10
PUSHQ %r11
CALL A
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ %r10, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET




return code: 3


===[good18.bminor Input]===
b1: integer = 3;
b2: integer = 6;
b3: integer = 9;

B: function integer(b3: integer, b4: integer) = {
	print b1 * b2 + b3 % b4;
	print '\n';
	b3 = 37;
	return b3;
}

main: function integer () = {
	print B(5, 3);
	return b3;
}

===[good18.bminor Output]===

.data
.global b1
b1: .quad 3
.global b2
b2: .quad 6
.global b3
b3: .quad 9

.text
.global B
B:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ b1, %r11
MOVQ b2, %r12
MOVQ %r11, %rax
IMULQ %r12
MOVQ %rax, %r12
MOVQ -8(%rbp), %r11
MOVQ -16(%rbp), %r13
MOVQ %r11, %rax
CQO
IDIVQ %r13
MOVQ %rdx, %r13
ADDQ %r12, %r13
MOVQ %r13, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $10, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_character
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $37, %r10
MOVQ %r10, -8(%rbp)
MOVQ %r10, %r11
MOVQ -8(%rbp), %r10
MOVQ %r10, %rax
JMP .B_epilogue

.B_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET

.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $5, %r12
MOVQ $3, %r13
MOVQ %r12, %rdi
MOVQ %r13, %rsi
PUSHQ %r10
PUSHQ %r11
CALL B
POPQ %r11
POPQ %r10
MOVQ %rax, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ b3, %r10
MOVQ %r10, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


20
37

return code: 9


===[good4.bminor Input]===
collatz: function integer(n: integer, acc: integer) = {
	print n, " ", acc, "\n";
	if (n == 1) return acc;

	if (n % 2 == 0) return collatz(n/2, acc + 1);
	else return collatz(3*n + 1, acc + 1);
}

main:function integer ()=
{
	return collatz(27, 0);
}

===[good4.bminor Output]===
.global collatz
collatz:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ -8(%rbp), %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s0: .string " "

.text
MOVQ $.s0, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ -16(%rbp), %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s1: .string "\n"

.text
MOVQ $.s1, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ -8(%rbp), %r10
MOVQ $1, %r11
CMPQ %r11, %r10
JE .L0
MOVQ $0, %r11
JMP .L1
.L0:
MOVQ $1, %r11
.L1:
CMP $0, %r11
JE .L2
MOVQ -16(%rbp), %r10
MOVQ %r10, %rax
JMP .collatz_epilogue
JMP .L3
.L2:
JMP .L3
.L3:
MOVQ -8(%rbp), %r10
MOVQ $2, %r11
MOVQ %r10, %rax
CQO
IDIVQ %r11
MOVQ %rdx, %r11
MOVQ $0, %r10
CMPQ %r10, %r11
JE .L4
MOVQ $0, %r10
JMP .L5
.L4:
MOVQ $1, %r10
.L5:
CMP $0, %r10
JE .L6
MOVQ -8(%rbp), %r11
MOVQ $2, %r12
MOVQ %r11, %rax
CQO
IDIVQ %r12
MOVQ %rax, %r12
MOVQ -16(%rbp), %r11
MOVQ $1, %r13
ADDQ %r11, %r13
MOVQ %r12, %rdi
MOVQ %r13, %rsi
PUSHQ %r10
PUSHQ %r11
CALL collatz
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ %r10, %rax
JMP .collatz_epilogue
JMP .L7
.L6:
MOVQ $3, %r11
MOVQ -8(%rbp), %r12
MOVQ %r11, %rax
IMULQ %r12
MOVQ %rax, %r12
MOVQ $1, %r11
ADDQ %r12, %r11
MOVQ -16(%rbp), %r12
MOVQ $1, %r13
ADDQ %r12, %r13
MOVQ %r11, %rdi
MOVQ %r13, %rsi
PUSHQ %r10
PUSHQ %r11
CALL collatz
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ %r10, %rax
JMP .collatz_epilogue
JMP .L7
.L7:

.collatz_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET

.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $27, %r11
MOVQ $0, %r12
MOVQ %r11, %rdi
MOVQ %r12, %rsi
PUSHQ %r10
PUSHQ %r11
CALL collatz
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ %r10, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


27 0
82 1
41 2
124 3
62 4
31 5
94 6
47 7
142 8
71 9
214 10
107 11
322 12
161 13
484 14
242 15
121 16
364 17
182 18
91 19
274 20
137 21
412 22
206 23
103 24
310 25
155 26
466 27
233 28
700 29
350 30
175 31
526 32
263 33
790 34
395 35
1186 36
593 37
1780 38
890 39
445 40
1336 41
668 42
334 43
167 44
502 45
251 46
754 47
377 48
1132 49
566 50
283 51
850 52
425 53
1276 54
638 55
319 56
958 57
479 58
1438 59
719 60
2158 61
1079 62
3238 63
1619 64
4858 65
2429 66
7288 67
3644 68
1822 69
911 70
2734 71
1367 72
4102 73
2051 74
6154 75
3077 76
9232 77
4616 78
2308 79
1154 80
577 81
1732 82
866 83
433 84
1300 85
650 86
325 87
976 88
488 89
244 90
122 91
61 92
184 93
92 94
46 95
23 96
70 97
35 98
106 99
53 100
160 101
80 102
40 103
20 104
10 105
5 106
16 107
8 108
4 109
2 110
1 111


return code: 111


===[good20.bminor Input]===
D: function integer() = {
	d1: integer = 5;
	d2: integer = d1 + 1; //6
	{
		d3: integer = 9;
		d2: integer = d3 + d1 - 3; //11
		d4: integer = -1;
		d2 = d2 + d3; //20
		print d2 - d4, "\n";
	}
	d4: integer = 16;
	print d2 - d4, '\n';
	{
		d4: integer = -2;
		d3: integer = 1000;
		print d3 + 10;
		print "\n";
		print d4;
		print '\n';
	}
	print d4;
	return 3;
}

main: function integer () = {
	return D();
}

===[good20.bminor Output]===
.global D
D:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $64, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $5, %r10
MOVQ %r10, -8(%rbp)
MOVQ -8(%rbp), %r10
MOVQ $1, %r11
ADDQ %r10, %r11
MOVQ %r11, -16(%rbp)
MOVQ $9, %r10
MOVQ %r10, -24(%rbp)
MOVQ -24(%rbp), %r10
MOVQ -8(%rbp), %r11
ADDQ %r10, %r11
MOVQ $3, %r10
SUBQ %r10, %r11
MOVQ %r11, -32(%rbp)
MOVQ $1, %r10
NEGQ %r10
MOVQ %r10, -40(%rbp)
MOVQ -32(%rbp), %r10
MOVQ -24(%rbp), %r11
ADDQ %r10, %r11
MOVQ %r11, -32(%rbp)
MOVQ %r11, %r10
MOVQ -32(%rbp), %r11
MOVQ -40(%rbp), %r12
SUBQ %r12, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s0: .string "\n"

.text
MOVQ $.s0, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $16, %r10
MOVQ %r10, -48(%rbp)
MOVQ -16(%rbp), %r11
MOVQ -48(%rbp), %r12
SUBQ %r12, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $10, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_character
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $2, %r10
NEGQ %r10
MOVQ %r10, -56(%rbp)
MOVQ $1000, %r10
MOVQ %r10, -64(%rbp)
MOVQ -64(%rbp), %r11
MOVQ $10, %r12
ADDQ %r11, %r12
MOVQ %r12, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s1: .string "\n"

.text
MOVQ $.s1, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ -56(%rbp), %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $10, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_character
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ -48(%rbp), %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $3, %r10
MOVQ %r10, %rax
JMP .D_epilogue

.D_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET

.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
PUSHQ %r10
PUSHQ %r11
CALL D
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ %r10, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


21
-10
1010
-2
16

return code: 3


===[good3.bminor Input]===
T: array [8] integer = {2, 1, 1, 2, 1, 2, 0, 3};

main:function integer ()=
{
	i: integer = 0;
        for (;;) {
		if (T[i] == 0) return T[5] + 10;
		else if (T[i] == 1) i++;
		else if (T[i] == 2) T[i++]--;
		else return 1;
	}

	return 0;
}

===[good3.bminor Output]===
TEST NOT PASSED

Parse successful!
T is correctly defined.
main is correctly defined.
i is correctly defined.
T resolves to global T.
i resolves to local 0.
T resolves to global T.
T resolves to global T.
i resolves to local 0.
i resolves to local 0.
T resolves to global T.
i resolves to local 0.
T resolves to global T.
i resolves to local 0.


return code: -11


===[good5.bminor Input]===
A: function boolean(x: integer, y: integer);
B: function integer(x: char);
C: function char(a: string);

main: function integer() = {
	if (A(B('d') - 1, 10)) {
		x: integer = 3;
		return 2 * B('!') + x;
	}
	return B(C("hello")) % 3;
}

A: function boolean(x: integer, y: integer) = {
	return x == y;
}

B: function integer(c: char) = {
	if (c == '!')
		return 10;
	else {return 11;}
}

C: function char(a: string) = {
	return '!';
}

===[good5.bminor Output]===

.data
.global A
.global B
.global C

.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $100, %r12
MOVQ %r12, %rdi
PUSHQ %r10
PUSHQ %r11
CALL B
POPQ %r11
POPQ %r10
MOVQ %rax, %r11
MOVQ $1, %r12
SUBQ %r12, %r11
MOVQ $10, %r12
MOVQ %r11, %rdi
MOVQ %r12, %rsi
PUSHQ %r10
PUSHQ %r11
CALL A
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
CMP $0, %r10
JE .L0
MOVQ $3, %r10
MOVQ %r10, -8(%rbp)
MOVQ $2, %r10
MOVQ $33, %r12
MOVQ %r12, %rdi
PUSHQ %r10
PUSHQ %r11
CALL B
POPQ %r11
POPQ %r10
MOVQ %rax, %r11
MOVQ %r10, %rax
IMULQ %r11
MOVQ %rax, %r11
MOVQ -8(%rbp), %r10
ADDQ %r11, %r10
MOVQ %r10, %rax
JMP .main_epilogue
JMP .L1
.L0:
JMP .L1
.L1:

.data
.s0: .string "hello"

.text
MOVQ $.s0, %r12
MOVQ %r12, %rdi
PUSHQ %r10
PUSHQ %r11
CALL C
POPQ %r11
POPQ %r10
MOVQ %rax, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL B
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $3, %r11
MOVQ %r10, %rax
CQO
IDIVQ %r11
MOVQ %rdx, %r11
MOVQ %r11, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET

.global A
A:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
PUSHQ %rsi
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ -8(%rbp), %r10
MOVQ -16(%rbp), %r11
CMPQ %r11, %r10
JE .L2
MOVQ $0, %r11
JMP .L3
.L2:
MOVQ $1, %r11
.L3:
MOVQ %r11, %rax
JMP .A_epilogue

.A_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET

.global B
B:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ -8(%rbp), %r10
MOVQ $33, %r11
CMPQ %r11, %r10
JE .L4
MOVQ $0, %r11
JMP .L5
.L4:
MOVQ $1, %r11
.L5:
CMP $0, %r11
JE .L6
MOVQ $10, %r10
MOVQ %r10, %rax
JMP .B_epilogue
JMP .L7
.L6:
MOVQ $11, %r10
MOVQ %r10, %rax
JMP .B_epilogue
JMP .L7
.L7:

.B_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET

.global C
C:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $33, %r10
MOVQ %r10, %rax
JMP .C_epilogue

.C_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET




return code: 23


===[good6.bminor Input]===
f: function boolean(b: boolean) = {
	return !b;
}

x: integer = -4;

main:function integer ()=
{
	y: integer = 10;
	if (f(f(f(f(f(x <= y)))))) return 1;
	else if (x < y - x*y) {
		return 4;
	} else return 2;
}

===[good6.bminor Output]===
TEST NOT PASSED

Parse successful!
f is correctly defined.
b is correctly defined.
b resolves to parameter 0.
x is correctly defined.
main is correctly defined.
y is correctly defined.
f resolves to global f.
f resolves to global f.
f resolves to global f.
f resolves to global f.
f resolves to global f.
x resolves to global x.
y resolves to local 0.
x resolves to global x.
y resolves to local 0.
x resolves to global x.
y resolves to local 0.
ERROR: cannot assign identifier x to -4 containing identifier or using an expression (variable value) in global scope.


return code: 1


===[good7.bminor Input]===
f: function void (i: integer) = {
	N: integer;
	for (N = 0; i > 0; i--) {
		print N;
		N = N + 1;
	}
}

main:function integer () = {
	N: integer = 6;
	for (;;N--) {
		f(N);
		print '\n';
		if (N == 0) return 0;
	}

	return 1;
}

===[good7.bminor Output]===
.global f
f:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $0, %r10
MOVQ %r10, -16(%rbp)
MOVQ $0, %r10
MOVQ %r10, -16(%rbp)
MOVQ %r10, %r11
.L0:
MOVQ -8(%rbp), %r10
MOVQ $0, %r11
CMPQ %r11, %r10
JG .L2
MOVQ $0, %r11
JMP .L3
.L2:
MOVQ $1, %r11
.L3:
CMP $0, %r11
JE .L1
MOVQ -16(%rbp), %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ -16(%rbp), %r10
MOVQ $1, %r11
ADDQ %r10, %r11
MOVQ %r11, -16(%rbp)
MOVQ %r11, %r10
MOVQ -8(%rbp), %r10
DECQ %r10
MOVQ %r10, -8(%rbp)
JMP .L0
.L1:

.f_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET

.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $6, %r10
MOVQ %r10, -8(%rbp)
.L4:
MOVQ $1, %r10
CMP $0, %r10
JE .L5
MOVQ -8(%rbp), %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $10, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_character
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ -8(%rbp), %r10
MOVQ $0, %r11
CMPQ %r11, %r10
JE .L6
MOVQ $0, %r11
JMP .L7
.L6:
MOVQ $1, %r11
.L7:
CMP $0, %r11
JE .L8
MOVQ $0, %r10
MOVQ %r10, %rax
JMP .main_epilogue
JMP .L9
.L8:
JMP .L9
.L9:
MOVQ -8(%rbp), %r10
DECQ %r10
MOVQ %r10, -8(%rbp)
JMP .L4
.L5:
MOVQ $1, %r10
MOVQ %r10, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


012345
01234
0123
012
01
0



return code: 0


===[good9.bminor Input]===
a: array[4] integer;
main: function integer() = {
	a[2] = 60;
	return a[2] + a[2] / 20 * 3 - a[1];
}

===[good9.bminor Output]===
TEST NOT PASSED

Parse successful!
a is correctly defined.
main is correctly defined.
a resolves to global a.
a resolves to global a.
a resolves to global a.
a resolves to global a.


return code: -11


===[good2.bminor Input]===


X: array [4] integer = {11, 30, 22, 0};

main: function integer () = {
	i: integer;
	for (i = 0; X[i] != 0; i++)
		print X[i], ' ', X[i] % 3, '\n';

	return 0;
}

===[good2.bminor Output]===

.data
.global X
X: .quad 11, 30, 22, 0

.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $0, %r10
MOVQ %r10, -8(%rbp)
MOVQ $0, %r10
MOVQ %r10, -8(%rbp)
MOVQ %r10, %r11
.L0:
MOVQ -8(%rbp), %r10
LEAQ X, %r11
MOVQ (%r11, %r10, 8), %r12
MOVQ $0, %r10
CMPQ %r10, %r12
JNE .L2
MOVQ $0, %r10
JMP .L3
.L2:
MOVQ $1, %r10
.L3:
CMP $0, %r10
JE .L1
MOVQ -8(%rbp), %r11
LEAQ X, %r12
MOVQ (%r12, %r11, 8), %r13
MOVQ %r13, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $32, %r12
MOVQ %r12, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_character
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ -8(%rbp), %r12
LEAQ X, %r13
MOVQ (%r13, %r12, 8), %r14
MOVQ $3, %r10
MOVQ %r14, %rax
CQO
IDIVQ %r10
MOVQ %rdx, %r10
MOVQ %r10, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $10, %r13
MOVQ %r13, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_character
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ -8(%rbp), %r10
MOVQ %r10, %r13
INCQ %r10
MOVQ %r10, -8(%rbp)
JMP .L0
.L1:
MOVQ $0, %r10
MOVQ %r10, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


11 2
30 0
22 1


return code: 0


===[good8.bminor Input]===
abs: function integer(n: integer) = {
	return n;
}

digits: array [6] integer = {
	14,
	8,
	6168,
	42,
	0,
	74546
};

main:function integer () = {
	digits[4] = -468;
	i: integer = 0;
	for (; abs(digits[i]) == digits[i];) {
		print digits[i];
		i = i + 1;
		print ' ';
	}
	print '\n';

	return 0;
}

===[good8.bminor Output]===
.global abs
abs:
PUSHQ %rbp
MOVQ %rsp, %rbp
PUSHQ %rdi
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ -8(%rbp), %r10
MOVQ %r10, %rax
JMP .abs_epilogue

.abs_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


.data
.global digits
digits: .quad 14, 8, 6168, 42, 0, 74546

.text
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $468, %r10
NEGQ %r10
MOVQ $4, %r12
LEAQ digits, %r13
LEAQ (%r13, %r12, 8), %r11
MOVQ %r10, (%r11)
MOVQ %r10, %r11
MOVQ $0, %r10
MOVQ %r10, -8(%rbp)
.L0:
MOVQ -8(%rbp), %r11
LEAQ digits, %r14
MOVQ (%r14, %r11, 8), %r15
MOVQ %r15, %rdi
PUSHQ %r10
PUSHQ %r11
CALL abs
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ -8(%rbp), %r10
LEAQ digits, %r14
MOVQ (%r14, %r10, 8), %r15
CMPQ %r15, %r10
JE .L2
MOVQ $0, %r15
JMP .L3
.L2:
MOVQ $1, %r15
.L3:
CMP $0, %r15
JE .L1
MOVQ -8(%rbp), %r14
LEAQ digits, %r15
MOVQ (%r15, %r14, 8), %rbx
MOVQ %rbx, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ -8(%rbp), %r10
MOVQ $1, %r15
ADDQ %r10, %r15
MOVQ %r15, -8(%rbp)
MOVQ %r15, %r10
MOVQ $32, %r15
MOVQ %r15, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_character
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
JMP .L0
.L1:
MOVQ $10, %r15
MOVQ %r15, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_character
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $0, %r10
MOVQ %r10, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET





return code: 0


===[good19.bminor Input]===
c1: integer = -1;
c3: integer = 100;

d1: integer = 1;
d2: integer = 2;

C: function integer(c1: integer, c2: integer) = {
	c3: integer = 11;
	c4: integer = 12;
	c5: integer = 13;
	return c1 + c2 + c3 + c4;
}

D: function integer(d1: integer, d2: integer) = {
	d3: integer = -3;
	d4: integer = 4;
	d5: integer = 5;
	return d1 + d2 + d3 - d4;
}

main: function integer() = {
	f: integer = D(6, 7);
	return C(1, 2);
}

===[good19.bminor Output]===
TEST NOT PASSED

Parse successful!
c1 is correctly defined.
c3 is correctly defined.
d1 is correctly defined.
d2 is correctly defined.
C is correctly defined.
c1 is correctly defined.
c2 is correctly defined.
c3 is correctly defined.
c4 is correctly defined.
c5 is correctly defined.
c1 resolves to parameter 0.
c2 resolves to parameter 1.
c3 resolves to local 0.
c4 resolves to local 1.
D is correctly defined.
d1 is correctly defined.
d2 is correctly defined.
d3 is correctly defined.
d4 is correctly defined.
d5 is correctly defined.
d1 resolves to parameter 0.
d2 resolves to parameter 1.
d3 resolves to local 0.
d4 resolves to local 1.
main is correctly defined.
f is correctly defined.
D resolves to global D.
C resolves to global C.
ERROR: cannot assign identifier c1 to -1 containing identifier or using an expression (variable value) in global scope.


return code: 1


===[good14.bminor Input]===
/*
Return pointer to (constant) global
string which is valid to display.
*/

s: string = "ok\n";

f: function string() = {
	t: string = s;
	return t;
}

main: function integer () = {
	print f();
	return 0;
}

===[good14.bminor Output]===

.data
.global s
.s: .string "ok\n"

.text
.global f
f:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $8, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
MOVQ $.s, %r10
MOVQ %r10, -8(%rbp)
MOVQ -8(%rbp), %r10
MOVQ %r10, %rax
JMP .f_epilogue

.f_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET

.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15
PUSHQ %r10
PUSHQ %r11
CALL f
POPQ %r11
POPQ %r10
MOVQ %rax, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $0, %r10
MOVQ %r10, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


ok


return code: 0


===[good16.bminor Input]===
// https://piazza.com/class/jziupd2lzpm7cy?cid=176

main: function integer() = {
	print "Testing printing literals", '\n', 123, "abc", true, false, 5;
	return 0;
}


===[good16.bminor Output]===
.global main
main:
PUSHQ %rbp
MOVQ %rsp, %rbp
SUBQ $0, %rsp
PUSHQ %rbx
PUSHQ %r12
PUSHQ %r13
PUSHQ %r14
PUSHQ %r15

.data
.s0: .string "Testing printing literals"

.text
MOVQ $.s0, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $10, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_character
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $123, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10

.data
.s1: .string "abc"

.text
MOVQ $.s1, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_string
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $1, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_boolean
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $0, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_boolean
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $5, %r11
MOVQ %r11, %rdi
PUSHQ %r10
PUSHQ %r11
CALL print_integer
POPQ %r11
POPQ %r10
MOVQ %rax, %r10
MOVQ $0, %r10
MOVQ %r10, %rax
JMP .main_epilogue

.main_epilogue:
POPQ %rbx
POPQ %r12
POPQ %r13
POPQ %r14
POPQ %r15
MOVQ %rbp, %rsp
POPQ %rbp
RET


Testing printing literals
123abctruefalse5

return code: 0


====Bad Tests====
===== SUMMARIZED CODEGEN RESULTS =====
{
  "student_tests": {
    "Good": {
      "correct": 20,
      "incorrect": 0
    },
    "Bad": {
      "correct": 0,
      "incorrect": 0
    }
  },
  "hidden_tests": {
    "Good": {
      "correct": 16,
      "incorrect": 4
    },
    "Bad": {
      "correct": 0,
      "incorrect": 0
    }
  }
}

Codegen Project Grade
-------------------

General Structure: 23/25
---------------------------------
Overall structure is correct. Missing some allowed
expressions at global scope such as expressing a negative number

Codegen - Functionality 13/15 
--------------------------------------------
Some segfaults in generated code, array issues

Codegen - Assembly Structure 10/10 
--------------------------------------------
Assembly looks well formed

Student Tests: 20/20
---------------------------
Passes all your tests.

Hidden Tests: 16/20
---------------------------
Fails 4 hidden tests

Code Style: 10/10
------------------------
Looks good. Nice work

Extra Credit: 0/10
------------------------

Total: 92/100
------------------------------------------
