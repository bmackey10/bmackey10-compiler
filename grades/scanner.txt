=====STUDENT TESTS=====
====Good Tests====
===[STUDENT TESTS/good0.bminor Input]===
/* all operators */
:
;
,
[
]
{
}
(
)
++
--
=
^
+
-
*
/
%
==
>=
<=
<
>
!=
-
!
&&
||
===[STUDENT TESTS/good0.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good0.bminor Output]===
TOKEN_COMMENT /* all operators */
TOKEN_COLON :
TOKEN_SEMICOLON ;
TOKEN_COMMA ,
TOKEN_OPEN_BRACKET [
TOKEN_CLOSE_BRACKET ]
TOKEN_OPEN_BRACE {
TOKEN_CLOSE_BRACE }
TOKEN_OPEN_PARENS (
TOKEN_CLOSE_PARENS )
TOKEN_INC ++
TOKEN_DEC --
TOKEN_ASSIGN =
TOKEN_EXPONENT ^
TOKEN_ADD +
TOKEN_SUBTRACT -
TOKEN_MULTIPLY *
TOKEN_DIVIDE /
TOKEN_MOD %
TOKEN_EQUALITY ==
TOKEN_GE >=
TOKEN_LE <=
TOKEN_LESS <
TOKEN_GREATER >
TOKEN_INEQUALITY !=
TOKEN_SUBTRACT -
TOKEN_NOT !
TOKEN_AND &&
TOKEN_OR ||




===[STUDENT TESTS/good1.bminor Input]===
// both types of 
/* comments work here */
/* also *** a comment */ 
/*******/
// still a comment //
// also a comment */
/* last one is tricky because a greedy regex would grab from line 4 to 6 */
===[STUDENT TESTS/good1.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good1.bminor Output]===
TOKEN_COMMENT // both types of 
TOKEN_COMMENT /* comments work here */
TOKEN_COMMENT /* also *** a comment */
TOKEN_COMMENT /*******/
TOKEN_COMMENT // still a comment //
TOKEN_COMMENT // also a comment */
TOKEN_COMMENT /* last one is tricky because a greedy regex would grab from line 4 to 6 */




===[STUDENT TESTS/good2.bminor Input]===
/* all keywords */
array
auto
boolean
char
else
false
float
for
function
if
integer
print
return
string
truevoid
while
===[STUDENT TESTS/good2.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good2.bminor Output]===
TOKEN_COMMENT /* all keywords */
TOKEN_KEYWORD array
TOKEN_KEYWORD auto
TOKEN_KEYWORD boolean
TOKEN_KEYWORD char
TOKEN_KEYWORD else
TOKEN_KEYWORD false
TOKEN_KEYWORD float
TOKEN_KEYWORD for
TOKEN_KEYWORD function
TOKEN_KEYWORD if
TOKEN_KEYWORD integer
TOKEN_KEYWORD print
TOKEN_KEYWORD return
TOKEN_KEYWORD string
TOKEN_KEYWORD truevoid
TOKEN_KEYWORD while




===[STUDENT TESTS/good3.bminor Input]===
/* strings */
""
"\tHi, my name is Brooke Mackey!\n"
"This text double slash will work \\\\"
" \"this was a tricky test case \" "
"Single quotes can either be escaped \' or not '"
===[STUDENT TESTS/good3.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good3.bminor Output]===
TOKEN_COMMENT /* strings */
TOKEN_STRING 
TOKEN_STRING 	Hi, my name is Brooke Mackey!

TOKEN_STRING This text double slash will work \\
TOKEN_STRING  "this was a tricky test case " 
TOKEN_STRING Single quotes can either be escaped ' or not '




===[STUDENT TESTS/good4.bminor Input]===
/* characters */
'.'
'a'
'z'
'\n'
'\t'
'\0x22'
'\0x5C'
'?'
'@'
===[STUDENT TESTS/good4.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good4.bminor Output]===
TOKEN_COMMENT /* characters */
TOKEN_CHAR .
TOKEN_CHAR a
TOKEN_CHAR z
TOKEN_CHAR 

TOKEN_CHAR 	
TOKEN_CHAR "
TOKEN_CHAR \
TOKEN_CHAR ?
TOKEN_CHAR @




===[STUDENT TESTS/good5.bminor Input]===
/* identifiers */
a
ab
abc123
abcd34gh1jklmn0pp
_hello
_these_work_too_12345
===[STUDENT TESTS/good5.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good5.bminor Output]===
TOKEN_COMMENT /* identifiers */
TOKEN_IDENTIFIER a
TOKEN_IDENTIFIER ab
TOKEN_IDENTIFIER abc123
TOKEN_IDENTIFIER abcd34gh1jklmn0pp
TOKEN_IDENTIFIER _hello
TOKEN_IDENTIFIER _these_work_too_12345




===[STUDENT TESTS/good6.bminor Input]===
/* integers and floats */
0
+100
-6777777777777777
1e56
38E-109
10000489.34
-12.238574
+29630.1
===[STUDENT TESTS/good6.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good6.bminor Output]===
TOKEN_COMMENT /* integers and floats */
TOKEN_INTEGER 0
TOKEN_INTEGER +100
TOKEN_INTEGER -6777777777777777
TOKEN_FLOAT 1e56
TOKEN_FLOAT 38E-109
TOKEN_FLOAT 10000489.34
TOKEN_FLOAT -12.238574
TOKEN_FLOAT +29630.1




===[STUDENT TESTS/good7.bminor Input]===
/* whitespace */

            x
                            y




z
// nothing happens for whtiespace
===[STUDENT TESTS/good7.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good7.bminor Output]===
TOKEN_COMMENT /* whitespace */
TOKEN_IDENTIFIER x
TOKEN_IDENTIFIER y
TOKEN_IDENTIFIER z
TOKEN_COMMENT // nothing happens for whtiespace




===[STUDENT TESTS/good8.bminor Input]===
int main(int argc, char *argv[]) {
    PROGRAM_NAME = argv[0];
    int argind = 1;

    while (argind < argc && strlen(argv[argind]) > 1 && argv[argind][0] == '-') {
        if (!strcmp(argv[argind], "--encode")) {
            if (!argv[argind + 1]) {
                usage(0);
            }
            return encode_file(argv[argind + 1]);
        } else if (!strcmp(argv[argind], "--scan")) {
            if (!argv[argind + 1]) {
                usage(0);
            }
            return scan_file(argv[argind + 1]);
        } else if (!strcmp(argv[argind], "--help")) {
            usage(0);
        }
        argind++;
    }

    return 0;
}
===[STUDENT TESTS/good8.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good8.bminor Output]===
TOKEN_IDENTIFIER int
TOKEN_IDENTIFIER main
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER int
TOKEN_IDENTIFIER argc
TOKEN_COMMA ,
TOKEN_KEYWORD char
TOKEN_MULTIPLY *
TOKEN_IDENTIFIER argv
TOKEN_OPEN_BRACKET [
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER PROGRAM_NAME
TOKEN_ASSIGN =
TOKEN_IDENTIFIER argv
TOKEN_OPEN_BRACKET [
TOKEN_INTEGER 0
TOKEN_CLOSE_BRACKET ]
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER int
TOKEN_IDENTIFIER argind
TOKEN_ASSIGN =
TOKEN_INTEGER 1
TOKEN_SEMICOLON ;
TOKEN_KEYWORD while
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER argind
TOKEN_LESS <
TOKEN_IDENTIFIER argc
TOKEN_AND &&
TOKEN_IDENTIFIER strlen
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER argv
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER argind
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_GREATER >
TOKEN_INTEGER 1
TOKEN_AND &&
TOKEN_IDENTIFIER argv
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER argind
TOKEN_CLOSE_BRACKET ]
TOKEN_OPEN_BRACKET [
TOKEN_INTEGER 0
TOKEN_CLOSE_BRACKET ]
TOKEN_EQUALITY ==
TOKEN_CHAR -
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_NOT !
TOKEN_IDENTIFIER strcmp
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER argv
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER argind
TOKEN_CLOSE_BRACKET ]
TOKEN_COMMA ,
TOKEN_STRING --encode
TOKEN_CLOSE_PARENS )
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_NOT !
TOKEN_IDENTIFIER argv
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER argind
TOKEN_ADD +
TOKEN_INTEGER 1
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER usage
TOKEN_OPEN_PARENS (
TOKEN_INTEGER 0
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD return
TOKEN_IDENTIFIER encode_file
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER argv
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER argind
TOKEN_ADD +
TOKEN_INTEGER 1
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD else
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_NOT !
TOKEN_IDENTIFIER strcmp
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER argv
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER argind
TOKEN_CLOSE_BRACKET ]
TOKEN_COMMA ,
TOKEN_STRING --scan
TOKEN_CLOSE_PARENS )
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_NOT !
TOKEN_IDENTIFIER argv
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER argind
TOKEN_ADD +
TOKEN_INTEGER 1
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER usage
TOKEN_OPEN_PARENS (
TOKEN_INTEGER 0
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD return
TOKEN_IDENTIFIER scan_file
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER argv
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER argind
TOKEN_ADD +
TOKEN_INTEGER 1
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD else
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_NOT !
TOKEN_IDENTIFIER strcmp
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER argv
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER argind
TOKEN_CLOSE_BRACKET ]
TOKEN_COMMA ,
TOKEN_STRING --help
TOKEN_CLOSE_PARENS )
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER usage
TOKEN_OPEN_PARENS (
TOKEN_INTEGER 0
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_IDENTIFIER argind
TOKEN_INC ++
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD return
TOKEN_INTEGER 0
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }




===[STUDENT TESTS/good9.bminor Input]===
int string_decode(const char *es, char *s) {

    int s_count = 0;

    if (es[0] != '\"' || es[strlen(es) - 1] != '\"') {
        if ((es[0] != '\'' || es[strlen(es) - 1] != '\'') && (strlen(es) == 3 || (strlen(es) == 4 && es[1] == '\\') || (strlen(es) == 7 && es[1] == '\\' && es[2] == '0' && es[3] == 'x'))) {
            printf("ERROR: The string or character %s is not properly enclosed in quotes.\n", es);
            exit(EXIT_FAILURE);
        }
    }

    for (int i = 1; i < strlen(es) - 1; i++) {
        
        if (es[i] == '\"') {
            printf("ERROR: The string or character %s contains an unescaped double quote.\n", es);
            exit(EXIT_FAILURE);
        } else if (es[i] == '\\') {
            i++;
            switch (es[i]) {
                case 'a':
                    s[s_count] = '\a';
                    break;
                case 'b':
                    s[s_count] = '\b';
                    break;
                case 'e':
                    s[s_count] = '\e';
                    break;
                case 'f':
                    s[s_count] = '\f';
                    break;
                case 'n':
                    s[s_count] = '\n';
                    break;
                case 'r':
                    s[s_count] = '\r';
                    break;
                case 't':
                    s[s_count] = '\t';
                    break;
                case 'v':
                    s[s_count] = '\v';
                    break;
                case '\\':
                    s[s_count] = '\\';
                    break;
                case '\'':
                    if (i == strlen(es) - 1) {
                        printf("ERROR: The character is not properly enclosed in quotes.\n");
                        exit(EXIT_FAILURE);
                    }
                    s[s_count] = '\'';
                    break;
                case '\"':
                    if (i == strlen(es) - 1) {
                        printf("ERROR: The string %s is not properly enclosed in double quotes.\n", es);
                        exit(EXIT_FAILURE);
                    }
                    s[s_count] = '\"';
                    break;
                case '0':
                    if (es[i + 1] == 'x' && isalnum(es[i + 2]) && isalnum(es[i + 3])) {
                        if (isalpha(es[i + 2]) && ((es[i + 2] >= 71 && es[i + 2] <= 90) || (es[i + 2] >= 103 && es[i + 2] <= 122))) {
                            printf("ERROR: The hexidecimal %c%c code does not exist.\n", es[i + 2], es[i + 3]);
                            exit(EXIT_FAILURE);
                        }
                        if (isalpha(es[i + 3]) && ((es[i + 3] >= 71 && es[i + 3] <= 90) || (es[i + 3] >= 103 && es[i + 3] <= 122))) {
                            printf("ERROR: The hexidecimal %c%c code does not exist.\n", es[i + 2], es[i + 3]);
                            exit(EXIT_FAILURE);
                        }
                        char temp[2] = {es[i + 2], es[i + 3]};
                        if (strtol(temp, 0, 16) > 255) {
                            printf("ERROR: The hexidecimal code is out of range.\n");
                            exit(EXIT_FAILURE);
                        } else if (strtol(temp, 0, 16) == 0) {
                            printf("ERROR: The hexidecimal %c%c code does not exist.\n", es[i + 2], es[i + 3]);
                            exit(EXIT_FAILURE);
                        } else {
                            s[s_count] = (int) strtol(temp, 0, 16);
                        }
                        i = i + 3;
                    } else {
                        printf("ERROR: The hexidecimal code does not exist.\n");
                        exit(EXIT_FAILURE);
                    }
                    break;
                default:
                    printf("ERROR: The backslash code \\%c does not exist.\n", es[i]);
                    exit(EXIT_FAILURE);
            }
        } else if (((int) es[i]) <= 126 && ((int) es[i]) >= 32) {
            s[s_count] = es[i];
        } else {
            printf("ERROR: The value %c's ASCII value is out of range or it contains in unknown character.\n", es[i]);
            exit(EXIT_FAILURE);
        }

        s_count++;
    }

    return 0;
}

int string_encode(const char *s, char *es) {

    int es_count = 1;

    *es = '\"';

    for (int i = 0; i < strlen(s); i++) {
        
        switch (s[i]) {
            case '\a':
                es[es_count] = '\\';
                es[es_count + 1] = 'a';
                es_count++;
                break;
            case '\b':
                es[es_count] = '\\';
                es[es_count + 1] = 'b';
                es_count++;
                break;
            case '\e':
                es[es_count] = '\\';
                es[es_count + 1] = 'e';
                es_count++;
                break;
            case '\f':
                es[es_count] = '\\';
                es[es_count + 1] = 'f';
                es_count++;
                break;
            case '\n':
                es[es_count] = '\\';
                es[es_count + 1] = 'n';
                es_count++;
                break;
            case '\r':
                es[es_count] = '\\';
                es[es_count + 1] = 'r';
                es_count++;
                break;
            case '\t':
                es[es_count] = '\\';
                es[es_count + 1] = 't';
                es_count++;
                break;
            case '\v':
                es[es_count] = '\\';
                es[es_count + 1] = 'v';
                es_count++;
                break;
            default:
                if (((int) s[i]) <= 126 && ((int) s[i]) >= 32) {
                    es[es_count] = s[i];
                } else if ((((int) s[i]) > 126 && ((int) s[i]) <= 255) || ((int) s[i]) < 32) {
                    char hex_value[2];
                    unsigned char hex_temp = s[i];
                    sprintf(hex_value, "%x", hex_temp);
                    es[es_count] = '\\';
                    es[es_count + 1] = '0';
                    es[es_count + 2] = 'x';
                    es[es_count + 3] = hex_value[0];
                    es[es_count + 4] = hex_value[1];
                    es_count = es_count + 4;
                } else {
                    printf("ERROR: The value %c's ASCII value is out of range or it contains in unknown character.\n", es[i]);
                    exit(EXIT_FAILURE);
                }
        }

        es_count++;
    }

    es[es_count] = '\"';

    return 0;
}

int encode_file(char *input_file) {

    FILE *fptr = fopen(input_file,"r");
    if (!fptr) {
        printf("ERROR: File path specified does not exist.");
        exit(EXIT_FAILURE);
    }

    char *s = (char *) calloc(256, sizeof(char));
    char *es = (char *) calloc(256, sizeof(char));

    fgets(es, BUFSIZ, fptr);

    if (strlen(es) > 257) {
        printf("ERROR: The string's or character's length is %li, which larger than 255 characters.\n", strlen(es) - 2);
        exit(EXIT_FAILURE);
    } else if (strlen(es) < 2) {
        printf("ERROR: The string or character is not properly enclosed in double quotes.\n");
        exit(EXIT_FAILURE);
    }

    if (string_decode(es, s) == 0) {
        char *output_es = (char *) calloc(256, sizeof(char));
        string_encode(s, output_es);
        printf("%s\n", output_es);
        free(output_es);
    } else {
        return EXIT_FAILURE;
    }

    free(s);
    free(es);
    fclose(fptr);

    return 0;
}
===[STUDENT TESTS/good9.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good9.bminor Output]===
TOKEN_IDENTIFIER int
TOKEN_IDENTIFIER string_decode
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER const
TOKEN_KEYWORD char
TOKEN_MULTIPLY *
TOKEN_IDENTIFIER es
TOKEN_COMMA ,
TOKEN_KEYWORD char
TOKEN_MULTIPLY *
TOKEN_IDENTIFIER s
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER int
TOKEN_IDENTIFIER s_count
TOKEN_ASSIGN =
TOKEN_INTEGER 0
TOKEN_SEMICOLON ;
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_INTEGER 0
TOKEN_CLOSE_BRACKET ]
TOKEN_INEQUALITY !=
TOKEN_CHAR "
TOKEN_OR ||
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER strlen
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_CLOSE_PARENS )
TOKEN_SUBTRACT -
TOKEN_INTEGER 1
TOKEN_CLOSE_BRACKET ]
TOKEN_INEQUALITY !=
TOKEN_CHAR "
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_INTEGER 0
TOKEN_CLOSE_BRACKET ]
TOKEN_INEQUALITY !=
TOKEN_CHAR '
TOKEN_OR ||
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER strlen
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_CLOSE_PARENS )
TOKEN_SUBTRACT -
TOKEN_INTEGER 1
TOKEN_CLOSE_BRACKET ]
TOKEN_INEQUALITY !=
TOKEN_CHAR '
TOKEN_CLOSE_PARENS )
TOKEN_AND &&
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER strlen
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_CLOSE_PARENS )
TOKEN_EQUALITY ==
TOKEN_INTEGER 3
TOKEN_OR ||
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER strlen
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_CLOSE_PARENS )
TOKEN_EQUALITY ==
TOKEN_INTEGER 4
TOKEN_AND &&
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_INTEGER 1
TOKEN_CLOSE_BRACKET ]
TOKEN_EQUALITY ==
TOKEN_CHAR \
TOKEN_CLOSE_PARENS )
TOKEN_OR ||
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER strlen
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_CLOSE_PARENS )
TOKEN_EQUALITY ==
TOKEN_INTEGER 7
TOKEN_AND &&
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_INTEGER 1
TOKEN_CLOSE_BRACKET ]
TOKEN_EQUALITY ==
TOKEN_CHAR \
TOKEN_AND &&
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_INTEGER 2
TOKEN_CLOSE_BRACKET ]
TOKEN_EQUALITY ==
TOKEN_CHAR 0
TOKEN_AND &&
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_INTEGER 3
TOKEN_CLOSE_BRACKET ]
TOKEN_EQUALITY ==
TOKEN_CHAR x
TOKEN_CLOSE_PARENS )
TOKEN_CLOSE_PARENS )
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER printf
TOKEN_OPEN_PARENS (
TOKEN_STRING ERROR: The string or character %s is not properly enclosed in quotes.

TOKEN_COMMA ,
TOKEN_IDENTIFIER es
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER exit
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER EXIT_FAILURE
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD for
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER int
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER 1
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_LESS <
TOKEN_IDENTIFIER strlen
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_CLOSE_PARENS )
TOKEN_SUBTRACT -
TOKEN_INTEGER 1
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_INC ++
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_CLOSE_BRACKET ]
TOKEN_EQUALITY ==
TOKEN_CHAR "
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER printf
TOKEN_OPEN_PARENS (
TOKEN_STRING ERROR: The string or character %s contains an unescaped double quote.

TOKEN_COMMA ,
TOKEN_IDENTIFIER es
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER exit
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER EXIT_FAILURE
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD else
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_CLOSE_BRACKET ]
TOKEN_EQUALITY ==
TOKEN_CHAR \
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER i
TOKEN_INC ++
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER switch
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER case
TOKEN_CHAR a
TOKEN_COLON :
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER s_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR 
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER case
TOKEN_CHAR b
TOKEN_COLON :
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER s_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR 
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER case
TOKEN_CHAR e
TOKEN_COLON :
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER s_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR 
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER case
TOKEN_CHAR f
TOKEN_COLON :
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER s_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR 
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER case
TOKEN_CHAR n
TOKEN_COLON :
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER s_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR 

TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER case
TOKEN_CHAR r
TOKEN_COLON :
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER s_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR 
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER case
TOKEN_CHAR t
TOKEN_COLON :
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER s_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR 	
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER case
TOKEN_CHAR v
TOKEN_COLON :
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER s_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR 
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER case
TOKEN_CHAR \
TOKEN_COLON :
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER s_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR \
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER case
TOKEN_CHAR '
TOKEN_COLON :
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER i
TOKEN_EQUALITY ==
TOKEN_IDENTIFIER strlen
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_CLOSE_PARENS )
TOKEN_SUBTRACT -
TOKEN_INTEGER 1
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER printf
TOKEN_OPEN_PARENS (
TOKEN_STRING ERROR: The character is not properly enclosed in quotes.

TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER exit
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER EXIT_FAILURE
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER s_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR '
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER case
TOKEN_CHAR "
TOKEN_COLON :
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER i
TOKEN_EQUALITY ==
TOKEN_IDENTIFIER strlen
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_CLOSE_PARENS )
TOKEN_SUBTRACT -
TOKEN_INTEGER 1
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER printf
TOKEN_OPEN_PARENS (
TOKEN_STRING ERROR: The string %s is not properly enclosed in double quotes.

TOKEN_COMMA ,
TOKEN_IDENTIFIER es
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER exit
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER EXIT_FAILURE
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER s_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR "
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER case
TOKEN_CHAR 0
TOKEN_COLON :
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 1
TOKEN_CLOSE_BRACKET ]
TOKEN_EQUALITY ==
TOKEN_CHAR x
TOKEN_AND &&
TOKEN_IDENTIFIER isalnum
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 2
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_AND &&
TOKEN_IDENTIFIER isalnum
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 3
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER isalpha
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 2
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_AND &&
TOKEN_OPEN_PARENS (
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 2
TOKEN_CLOSE_BRACKET ]
TOKEN_GE >=
TOKEN_INTEGER 71
TOKEN_AND &&
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 2
TOKEN_CLOSE_BRACKET ]
TOKEN_LE <=
TOKEN_INTEGER 90
TOKEN_CLOSE_PARENS )
TOKEN_OR ||
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 2
TOKEN_CLOSE_BRACKET ]
TOKEN_GE >=
TOKEN_INTEGER 103
TOKEN_AND &&
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 2
TOKEN_CLOSE_BRACKET ]
TOKEN_LE <=
TOKEN_INTEGER 122
TOKEN_CLOSE_PARENS )
TOKEN_CLOSE_PARENS )
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER printf
TOKEN_OPEN_PARENS (
TOKEN_STRING ERROR: The hexidecimal %c%c code does not exist.

TOKEN_COMMA ,
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 2
TOKEN_CLOSE_BRACKET ]
TOKEN_COMMA ,
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 3
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER exit
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER EXIT_FAILURE
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER isalpha
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 3
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_AND &&
TOKEN_OPEN_PARENS (
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 3
TOKEN_CLOSE_BRACKET ]
TOKEN_GE >=
TOKEN_INTEGER 71
TOKEN_AND &&
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 3
TOKEN_CLOSE_BRACKET ]
TOKEN_LE <=
TOKEN_INTEGER 90
TOKEN_CLOSE_PARENS )
TOKEN_OR ||
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 3
TOKEN_CLOSE_BRACKET ]
TOKEN_GE >=
TOKEN_INTEGER 103
TOKEN_AND &&
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 3
TOKEN_CLOSE_BRACKET ]
TOKEN_LE <=
TOKEN_INTEGER 122
TOKEN_CLOSE_PARENS )
TOKEN_CLOSE_PARENS )
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER printf
TOKEN_OPEN_PARENS (
TOKEN_STRING ERROR: The hexidecimal %c%c code does not exist.

TOKEN_COMMA ,
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 2
TOKEN_CLOSE_BRACKET ]
TOKEN_COMMA ,
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 3
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER exit
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER EXIT_FAILURE
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD char
TOKEN_IDENTIFIER temp
TOKEN_OPEN_BRACKET [
TOKEN_INTEGER 2
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 2
TOKEN_CLOSE_BRACKET ]
TOKEN_COMMA ,
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 3
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_BRACE }
TOKEN_SEMICOLON ;
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER strtol
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER temp
TOKEN_COMMA ,
TOKEN_INTEGER 0
TOKEN_COMMA ,
TOKEN_INTEGER 16
TOKEN_CLOSE_PARENS )
TOKEN_GREATER >
TOKEN_INTEGER 255
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER printf
TOKEN_OPEN_PARENS (
TOKEN_STRING ERROR: The hexidecimal code is out of range.

TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER exit
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER EXIT_FAILURE
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD else
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER strtol
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER temp
TOKEN_COMMA ,
TOKEN_INTEGER 0
TOKEN_COMMA ,
TOKEN_INTEGER 16
TOKEN_CLOSE_PARENS )
TOKEN_EQUALITY ==
TOKEN_INTEGER 0
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER printf
TOKEN_OPEN_PARENS (
TOKEN_STRING ERROR: The hexidecimal %c%c code does not exist.

TOKEN_COMMA ,
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 2
TOKEN_CLOSE_BRACKET ]
TOKEN_COMMA ,
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 3
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER exit
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER EXIT_FAILURE
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD else
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER s_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER int
TOKEN_CLOSE_PARENS )
TOKEN_IDENTIFIER strtol
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER temp
TOKEN_COMMA ,
TOKEN_INTEGER 0
TOKEN_COMMA ,
TOKEN_INTEGER 16
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_IDENTIFIER i
TOKEN_ADD +
TOKEN_INTEGER 3
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD else
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER printf
TOKEN_OPEN_PARENS (
TOKEN_STRING ERROR: The hexidecimal code does not exist.

TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER exit
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER EXIT_FAILURE
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER default
TOKEN_COLON :
TOKEN_IDENTIFIER printf
TOKEN_OPEN_PARENS (
TOKEN_STRING ERROR: The backslash code \%c does not exist.

TOKEN_COMMA ,
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER exit
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER EXIT_FAILURE
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD else
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_OPEN_PARENS (
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER int
TOKEN_CLOSE_PARENS )
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_LE <=
TOKEN_INTEGER 126
TOKEN_AND &&
TOKEN_OPEN_PARENS (
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER int
TOKEN_CLOSE_PARENS )
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_GE >=
TOKEN_INTEGER 32
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER s_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_CLOSE_BRACKET ]
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD else
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER printf
TOKEN_OPEN_PARENS (
TOKEN_STRING ERROR: The value %c's ASCII value is out of range or it contains in unknown character.

TOKEN_COMMA ,
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER exit
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER EXIT_FAILURE
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_IDENTIFIER s_count
TOKEN_INC ++
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD return
TOKEN_INTEGER 0
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_IDENTIFIER int
TOKEN_IDENTIFIER string_encode
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER const
TOKEN_KEYWORD char
TOKEN_MULTIPLY *
TOKEN_IDENTIFIER s
TOKEN_COMMA ,
TOKEN_KEYWORD char
TOKEN_MULTIPLY *
TOKEN_IDENTIFIER es
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER int
TOKEN_IDENTIFIER es_count
TOKEN_ASSIGN =
TOKEN_INTEGER 1
TOKEN_SEMICOLON ;
TOKEN_MULTIPLY *
TOKEN_IDENTIFIER es
TOKEN_ASSIGN =
TOKEN_CHAR "
TOKEN_SEMICOLON ;
TOKEN_KEYWORD for
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER int
TOKEN_IDENTIFIER i
TOKEN_ASSIGN =
TOKEN_INTEGER 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_LESS <
TOKEN_IDENTIFIER strlen
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER s
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_INC ++
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER switch
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER case
TOKEN_CHAR 
TOKEN_COLON :
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR \
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_ADD +
TOKEN_INTEGER 1
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR a
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es_count
TOKEN_INC ++
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER case
TOKEN_CHAR 
TOKEN_COLON :
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR \
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_ADD +
TOKEN_INTEGER 1
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR b
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es_count
TOKEN_INC ++
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER case
TOKEN_CHAR 
TOKEN_COLON :
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR \
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_ADD +
TOKEN_INTEGER 1
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR e
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es_count
TOKEN_INC ++
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER case
TOKEN_CHAR 
TOKEN_COLON :
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR \
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_ADD +
TOKEN_INTEGER 1
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR f
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es_count
TOKEN_INC ++
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER case
TOKEN_CHAR 

TOKEN_COLON :
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR \
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_ADD +
TOKEN_INTEGER 1
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR n
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es_count
TOKEN_INC ++
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER case
TOKEN_CHAR 
TOKEN_COLON :
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR \
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_ADD +
TOKEN_INTEGER 1
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR r
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es_count
TOKEN_INC ++
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER case
TOKEN_CHAR 	
TOKEN_COLON :
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR \
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_ADD +
TOKEN_INTEGER 1
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR t
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es_count
TOKEN_INC ++
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER case
TOKEN_CHAR 
TOKEN_COLON :
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR \
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_ADD +
TOKEN_INTEGER 1
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR v
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es_count
TOKEN_INC ++
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER break
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER default
TOKEN_COLON :
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_OPEN_PARENS (
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER int
TOKEN_CLOSE_PARENS )
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_LE <=
TOKEN_INTEGER 126
TOKEN_AND &&
TOKEN_OPEN_PARENS (
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER int
TOKEN_CLOSE_PARENS )
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_GE >=
TOKEN_INTEGER 32
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_CLOSE_BRACKET ]
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD else
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_OPEN_PARENS (
TOKEN_OPEN_PARENS (
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER int
TOKEN_CLOSE_PARENS )
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_GREATER >
TOKEN_INTEGER 126
TOKEN_AND &&
TOKEN_OPEN_PARENS (
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER int
TOKEN_CLOSE_PARENS )
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_LE <=
TOKEN_INTEGER 255
TOKEN_CLOSE_PARENS )
TOKEN_OR ||
TOKEN_OPEN_PARENS (
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER int
TOKEN_CLOSE_PARENS )
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_LESS <
TOKEN_INTEGER 32
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_KEYWORD char
TOKEN_IDENTIFIER hex_value
TOKEN_OPEN_BRACKET [
TOKEN_INTEGER 2
TOKEN_CLOSE_BRACKET ]
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER unsigned
TOKEN_KEYWORD char
TOKEN_IDENTIFIER hex_temp
TOKEN_ASSIGN =
TOKEN_IDENTIFIER s
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_CLOSE_BRACKET ]
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER sprintf
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER hex_value
TOKEN_COMMA ,
TOKEN_STRING %x
TOKEN_COMMA ,
TOKEN_IDENTIFIER hex_temp
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR \
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_ADD +
TOKEN_INTEGER 1
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_ADD +
TOKEN_INTEGER 2
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR x
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_ADD +
TOKEN_INTEGER 3
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_IDENTIFIER hex_value
TOKEN_OPEN_BRACKET [
TOKEN_INTEGER 0
TOKEN_CLOSE_BRACKET ]
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_ADD +
TOKEN_INTEGER 4
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_IDENTIFIER hex_value
TOKEN_OPEN_BRACKET [
TOKEN_INTEGER 1
TOKEN_CLOSE_BRACKET ]
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER es_count
TOKEN_ASSIGN =
TOKEN_IDENTIFIER es_count
TOKEN_ADD +
TOKEN_INTEGER 4
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD else
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER printf
TOKEN_OPEN_PARENS (
TOKEN_STRING ERROR: The value %c's ASCII value is out of range or it contains in unknown character.

TOKEN_COMMA ,
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER i
TOKEN_CLOSE_BRACKET ]
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER exit
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER EXIT_FAILURE
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_CLOSE_BRACE }
TOKEN_IDENTIFIER es_count
TOKEN_INC ++
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_IDENTIFIER es
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER es_count
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_CHAR "
TOKEN_SEMICOLON ;
TOKEN_KEYWORD return
TOKEN_INTEGER 0
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_IDENTIFIER int
TOKEN_IDENTIFIER encode_file
TOKEN_OPEN_PARENS (
TOKEN_KEYWORD char
TOKEN_MULTIPLY *
TOKEN_IDENTIFIER input_file
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER FILE
TOKEN_MULTIPLY *
TOKEN_IDENTIFIER fptr
TOKEN_ASSIGN =
TOKEN_IDENTIFIER fopen
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER input_file
TOKEN_COMMA ,
TOKEN_STRING r
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_NOT !
TOKEN_IDENTIFIER fptr
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER printf
TOKEN_OPEN_PARENS (
TOKEN_STRING ERROR: File path specified does not exist.
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER exit
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER EXIT_FAILURE
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD char
TOKEN_MULTIPLY *
TOKEN_IDENTIFIER s
TOKEN_ASSIGN =
TOKEN_OPEN_PARENS (
TOKEN_KEYWORD char
TOKEN_MULTIPLY *
TOKEN_CLOSE_PARENS )
TOKEN_IDENTIFIER calloc
TOKEN_OPEN_PARENS (
TOKEN_INTEGER 256
TOKEN_COMMA ,
TOKEN_IDENTIFIER sizeof
TOKEN_OPEN_PARENS (
TOKEN_KEYWORD char
TOKEN_CLOSE_PARENS )
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_KEYWORD char
TOKEN_MULTIPLY *
TOKEN_IDENTIFIER es
TOKEN_ASSIGN =
TOKEN_OPEN_PARENS (
TOKEN_KEYWORD char
TOKEN_MULTIPLY *
TOKEN_CLOSE_PARENS )
TOKEN_IDENTIFIER calloc
TOKEN_OPEN_PARENS (
TOKEN_INTEGER 256
TOKEN_COMMA ,
TOKEN_IDENTIFIER sizeof
TOKEN_OPEN_PARENS (
TOKEN_KEYWORD char
TOKEN_CLOSE_PARENS )
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER fgets
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_COMMA ,
TOKEN_IDENTIFIER BUFSIZ
TOKEN_COMMA ,
TOKEN_IDENTIFIER fptr
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER strlen
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_CLOSE_PARENS )
TOKEN_GREATER >
TOKEN_INTEGER 257
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER printf
TOKEN_OPEN_PARENS (
TOKEN_STRING ERROR: The string's or character's length is %li, which larger than 255 characters.

TOKEN_COMMA ,
TOKEN_IDENTIFIER strlen
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_CLOSE_PARENS )
TOKEN_SUBTRACT -
TOKEN_INTEGER 2
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER exit
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER EXIT_FAILURE
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD else
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER strlen
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_CLOSE_PARENS )
TOKEN_LESS <
TOKEN_INTEGER 2
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER printf
TOKEN_OPEN_PARENS (
TOKEN_STRING ERROR: The string or character is not properly enclosed in double quotes.

TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER exit
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER EXIT_FAILURE
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER string_decode
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_COMMA ,
TOKEN_IDENTIFIER s
TOKEN_CLOSE_PARENS )
TOKEN_EQUALITY ==
TOKEN_INTEGER 0
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_KEYWORD char
TOKEN_MULTIPLY *
TOKEN_IDENTIFIER output_es
TOKEN_ASSIGN =
TOKEN_OPEN_PARENS (
TOKEN_KEYWORD char
TOKEN_MULTIPLY *
TOKEN_CLOSE_PARENS )
TOKEN_IDENTIFIER calloc
TOKEN_OPEN_PARENS (
TOKEN_INTEGER 256
TOKEN_COMMA ,
TOKEN_IDENTIFIER sizeof
TOKEN_OPEN_PARENS (
TOKEN_KEYWORD char
TOKEN_CLOSE_PARENS )
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER string_encode
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER s
TOKEN_COMMA ,
TOKEN_IDENTIFIER output_es
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER printf
TOKEN_OPEN_PARENS (
TOKEN_STRING %s

TOKEN_COMMA ,
TOKEN_IDENTIFIER output_es
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER free
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER output_es
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD else
TOKEN_OPEN_BRACE {
TOKEN_KEYWORD return
TOKEN_IDENTIFIER EXIT_FAILURE
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_IDENTIFIER free
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER s
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER free
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER es
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER fclose
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER fptr
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_KEYWORD return
TOKEN_INTEGER 0
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }




====Bad Tests====
===[STUDENT TESTS/bad0.bminor Input]===
// unmatched quote
"
'
===[STUDENT TESTS/bad0.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad0.bminor Output]===
TOKEN_COMMENT // unmatched quote
ERROR: Unrecognized token.



===[STUDENT TESTS/bad1.bminor Input]===
/* these characters can't be parsed */
$
@
#
===[STUDENT TESTS/bad1.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad1.bminor Output]===
TOKEN_COMMENT /* these characters can't be parsed */
ERROR: Unrecognized token.



===[STUDENT TESTS/bad2.bminor Input]===
/* this character is too long */

'ca'
===[STUDENT TESTS/bad2.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad2.bminor Output]===
TOKEN_COMMENT /* this character is too long */
ERROR: Unrecognized token.



===[STUDENT TESTS/bad3.bminor Input]===
// This number is too big

int x = 9223372036854775808
===[STUDENT TESTS/bad3.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad3.bminor Output]===
TOKEN_COMMENT // This number is too big
TOKEN_IDENTIFIER int
TOKEN_IDENTIFIER x
TOKEN_ASSIGN =
ERROR: 9223372036854775808 out of range of type long.



===[STUDENT TESTS/bad4.bminor Input]===
// a float has to have a value after the decimal

-50006.

===[STUDENT TESTS/bad4.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad4.bminor Output]===
TOKEN_COMMENT // a float has to have a value after the decimal
TOKEN_INTEGER -50006
ERROR: Unrecognized token.



===[STUDENT TESTS/bad5.bminor Input]===
// you can't do this
a | b
or this
a & b
===[STUDENT TESTS/bad5.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad5.bminor Output]===
TOKEN_COMMENT // you can't do this
TOKEN_IDENTIFIER a
ERROR: Unrecognized token.



===[STUDENT TESTS/bad6.bminor Input]===
// this is a bad ASCII code

'\0x;;'
===[STUDENT TESTS/bad6.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad6.bminor Output]===
TOKEN_COMMENT // this is a bad ASCII code
ERROR: Unrecognized token.



===[STUDENT TESTS/bad7.bminor Input]===
"A string can contain \n the newline backslash code."

"A string cannot contain 

a literal newline."
===[STUDENT TESTS/bad7.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad7.bminor Output]===
TOKEN_STRING A string can contain 
 the newline backslash code.
ERROR: Unrecognized token.



===[STUDENT TESTS/bad8.bminor Input]===
this identifier will be too long
rdTDhRXSt8LAqdCsRFAHzTpvnaO7dcfMRedn7WqRBIQRRKZJithHjV9W3F3P3T29sXFRvvLBHNSi6MBAhNGGaa4p2pqixcV9SYi8KyWl5733S5zyYwluUUIu0lQjR89yIJqLoy5bWGXbL6cHkIDvq17Bln28nwDP1S4Huh3YIvuM5z1gUyfYLSqtDPb3rsqbi4iLO58Ga1oMl6JNJRpTLWiKnpV6AUWV48jNWqih9rfAlidT5sQowMTuSimqt8gVHG
===[STUDENT TESTS/bad8.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad8.bminor Output]===
TOKEN_IDENTIFIER this
TOKEN_IDENTIFIER identifier
TOKEN_IDENTIFIER will
TOKEN_IDENTIFIER be
TOKEN_IDENTIFIER too
TOKEN_IDENTIFIER long
ERROR: The input length is 256, which larger than 255 characters.




===[STUDENT TESTS/bad9.bminor Input]===
#include "encode.h"

int string_decode(const char *es, char *s) {

    int s_count = 0;

    if (es[0] != '\"' || es[strlen(es) - 1] != '\"') {
        if ((es[0] != '\'' || es[strlen(es) - 1] != '\'') && (strlen(es) == 3 || (strlen(es) == 4 && es[1] == '\\') || (strlen(es) == 7 && es[1] == '\\' && es[2] == '0' && es[3] == 'x'))) {
            printf("ERROR: The string or character %s is not properly enclosed in quotes.\n", es);
            exit(EXIT_FAILURE);
        }
    }

    for (int i = 1; i < strlen(es) - 1; i++) {
        
        if (es[i] == '\"') {
            printf("ERROR: The string or character %s contains an unescaped double quote.\n", es);
            exit(EXIT_FAILURE);
        } else if (es[i] == '\\') {
            i++;
            switch (es[i]) {
                case 'a':
                    s[s_count] = '\a';
                    break;
                case 'b':
                    s[s_count] = '\b';
                    break;
                case 'e':
                    s[s_count] = '\e';
                    break;
                case 'f':
                    s[s_count] = '\f';
                    break;
                case 'n':
                    s[s_count] = '\n';
                    break;
                case 'r':
                    s[s_count] = '\r';
                    break;
                case 't':
                    s[s_count] = '\t';
                    break;
                case 'v':
                    s[s_count] = '\v';
                    break;
                case '\\':
                    s[s_count] = '\\';
                    break;
                case '\'':
                    if (i == strlen(es) - 1) {
                        printf("ERROR: The character is not properly enclosed in quotes.\n");
                        exit(EXIT_FAILURE);
                    }
                    s[s_count] = '\'';
                    break;
                case '\"':
                    if (i == strlen(es) - 1) {
                        printf("ERROR: The string %s is not properly enclosed in double quotes.\n", es);
                        exit(EXIT_FAILURE);
                    }
                    s[s_count] = '\"';
                    break;
                case '0':
                    if (es[i + 1] == 'x' && isalnum(es[i + 2]) && isalnum(es[i + 3])) {
                        if (isalpha(es[i + 2]) && ((es[i + 2] >= 71 && es[i + 2] <= 90) || (es[i + 2] >= 103 && es[i + 2] <= 122))) {
                            printf("ERROR: The hexidecimal %c%c code does not exist.\n", es[i + 2], es[i + 3]);
                            exit(EXIT_FAILURE);
                        }
                        if (isalpha(es[i + 3]) && ((es[i + 3] >= 71 && es[i + 3] <= 90) || (es[i + 3] >= 103 && es[i + 3] <= 122))) {
                            printf("ERROR: The hexidecimal %c%c code does not exist.\n", es[i + 2], es[i + 3]);
                            exit(EXIT_FAILURE);
                        }
                        char temp[2] = {es[i + 2], es[i + 3]};
                        if (strtol(temp, 0, 16) > 255) {
                            printf("ERROR: The hexidecimal code is out of range.\n");
                            exit(EXIT_FAILURE);
                        } else if (strtol(temp, 0, 16) == 0) {
                            printf("ERROR: The hexidecimal %c%c code does not exist.\n", es[i + 2], es[i + 3]);
                            exit(EXIT_FAILURE);
                        } else {
                            s[s_count] = (int) strtol(temp, 0, 16);
                        }
                        i = i + 3;
                    } else {
                        printf("ERROR: The hexidecimal code does not exist.\n");
                        exit(EXIT_FAILURE);
                    }
                    break;
                default:
                    printf("ERROR: The backslash code \\%c does not exist.\n", es[i]);
                    exit(EXIT_FAILURE);
            }
        } else if (((int) es[i]) <= 126 && ((int) es[i]) >= 32) {
            s[s_count] = es[i];
        } else {
            printf("ERROR: The value %c's ASCII value is out of range or it contains in unknown character.\n", es[i]);
            exit(EXIT_FAILURE);
        }

        s_count++;
    }

    s[s_count] = '\0';

    return 0;
}

int string_encode(const char *s, char *es) {

    int es_count = 1;

    *es = '\"';

    for (int i = 0; i < strlen(s); i++) {
        
        switch (s[i]) {
            case '\a':
                es[es_count] = '\\';
                es[es_count + 1] = 'a';
                es_count++;
                break;
            case '\b':
                es[es_count] = '\\';
                es[es_count + 1] = 'b';
                es_count++;
                break;
            case '\e':
                es[es_count] = '\\';
                es[es_count + 1] = 'e';
                es_count++;
                break;
            case '\f':
                es[es_count] = '\\';
                es[es_count + 1] = 'f';
                es_count++;
                break;
            case '\n':
                es[es_count] = '\\';
                es[es_count + 1] = 'n';
                es_count++;
                break;
            case '\r':
                es[es_count] = '\\';
                es[es_count + 1] = 'r';
                es_count++;
                break;
            case '\t':
                es[es_count] = '\\';
                es[es_count + 1] = 't';
                es_count++;
                break;
            case '\v':
                es[es_count] = '\\';
                es[es_count + 1] = 'v';
                es_count++;
                break;
            default:
                if (((int) s[i]) <= 126 && ((int) s[i]) >= 32) {
                    es[es_count] = s[i];
                } else if ((((int) s[i]) > 126 && ((int) s[i]) <= 255) || ((int) s[i]) < 32) {
                    char hex_value[2];
                    unsigned char hex_temp = s[i];
                    sprintf(hex_value, "%x", hex_temp);
                    es[es_count] = '\\';
                    es[es_count + 1] = '0';
                    es[es_count + 2] = 'x';
                    es[es_count + 3] = hex_value[0];
                    es[es_count + 4] = hex_value[1];
                    es_count = es_count + 4;
                } else {
                    printf("ERROR: The value %c's ASCII value is out of range or it contains in unknown character.\n", es[i]);
                    exit(EXIT_FAILURE);
                }
        }

        es_count++;
    }

    es[es_count] = '\"';

    return 0;
}

int encode_file(char *input_file) {

    FILE *fptr = fopen(input_file,"r");
    if (!fptr) {
        printf("ERROR: File path specified does not exist.");
        exit(EXIT_FAILURE);
    }

    char *s = (char *) calloc(256, sizeof(char));
    char *es = (char *) calloc(256, sizeof(char));

    fgets(es, BUFSIZ, fptr);

    if (strlen(es) > 257) {
        printf("ERROR: The string's or character's length is %li, which larger than 255 characters.\n", strlen(es) - 2);
        exit(EXIT_FAILURE);
    } else if (strlen(es) < 2) {
        printf("ERROR: The string or character is not properly enclosed in double quotes.\n");
        exit(EXIT_FAILURE);
    }

    if (string_decode(es, s) == 0) {
        char *output_es = (char *) calloc(256, sizeof(char));
        string_encode(s, output_es);
        printf("%s\n", output_es);
        free(output_es);
    } else {
        return EXIT_FAILURE;
    }

    free(s);
    free(es);
    fclose(fptr);

    return 0;
}
===[STUDENT TESTS/bad9.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad9.bminor Output]===
ERROR: Unrecognized token.



=====HIDDEN TESTS=====
====Good Tests====
===[HIDDEN TESTS/good11.bminor Input]===
// some more complicated corner cases
z = -(5 * 4);
z = 15 + 5 - 4*3/7;
z = x + (y * 5 - (4 + 20/v) - 15) % 6 + z; //long integer expr
z+++; // these will cause parsing errors
w---;


===[HIDDEN TESTS/good11.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good11.bminor Output]===
TOKEN_COMMENT // some more complicated corner cases
TOKEN_IDENTIFIER z
TOKEN_ASSIGN =
TOKEN_SUBTRACT -
TOKEN_OPEN_PARENS (
TOKEN_INTEGER 5
TOKEN_MULTIPLY *
TOKEN_INTEGER 4
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER z
TOKEN_ASSIGN =
TOKEN_INTEGER 15
TOKEN_ADD +
TOKEN_INTEGER 5
TOKEN_SUBTRACT -
TOKEN_INTEGER 4
TOKEN_MULTIPLY *
TOKEN_INTEGER 3
TOKEN_DIVIDE /
TOKEN_INTEGER 7
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER z
TOKEN_ASSIGN =
TOKEN_IDENTIFIER x
TOKEN_ADD +
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER y
TOKEN_MULTIPLY *
TOKEN_INTEGER 5
TOKEN_SUBTRACT -
TOKEN_OPEN_PARENS (
TOKEN_INTEGER 4
TOKEN_ADD +
TOKEN_INTEGER 20
TOKEN_DIVIDE /
TOKEN_IDENTIFIER v
TOKEN_CLOSE_PARENS )
TOKEN_SUBTRACT -
TOKEN_INTEGER 15
TOKEN_CLOSE_PARENS )
TOKEN_MOD %
TOKEN_INTEGER 6
TOKEN_ADD +
TOKEN_IDENTIFIER z
TOKEN_SEMICOLON ;
TOKEN_COMMENT //long integer expr
TOKEN_IDENTIFIER z
TOKEN_INC ++
TOKEN_ADD +
TOKEN_SEMICOLON ;
TOKEN_COMMENT // these will cause parsing errors
TOKEN_IDENTIFIER w
TOKEN_DEC --
TOKEN_SUBTRACT -
TOKEN_SEMICOLON ;




===[HIDDEN TESTS/good12.bminor Input]===
//tests the for/print keyword and while keyword
x:integer;
for(x = 0; x < 5; x++)
{
	print "counting: ", x;
}
a:integer = 0;
while(a > 0)
{
	a--;
}



===[HIDDEN TESTS/good12.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good12.bminor Output]===
TOKEN_COMMENT //tests the for/print keyword and while keyword
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_KEYWORD integer
TOKEN_SEMICOLON ;
TOKEN_KEYWORD for
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER x
TOKEN_ASSIGN =
TOKEN_INTEGER 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER x
TOKEN_LESS <
TOKEN_INTEGER 5
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER x
TOKEN_INC ++
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_KEYWORD print
TOKEN_STRING counting: 
TOKEN_COMMA ,
TOKEN_IDENTIFIER x
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_IDENTIFIER a
TOKEN_COLON :
TOKEN_KEYWORD integer
TOKEN_ASSIGN =
TOKEN_INTEGER 0
TOKEN_SEMICOLON ;
TOKEN_KEYWORD while
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER a
TOKEN_GREATER >
TOKEN_INTEGER 0
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER a
TOKEN_DEC --
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }




===[HIDDEN TESTS/good13.bminor Input]===
//test some odd identifier names
ident55
ident55_
ident__55__
thisIsAReallyReallyLongIdentifierNameThatHasTonsOfLettersInIt = 7
variable_names_may_contain_underscores_
_variables_can_start_with_an_underscore_67
7minus5 

===[HIDDEN TESTS/good13.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good13.bminor Output]===
TOKEN_COMMENT //test some odd identifier names
TOKEN_IDENTIFIER ident55
TOKEN_IDENTIFIER ident55_
TOKEN_IDENTIFIER ident__55__
TOKEN_IDENTIFIER thisIsAReallyReallyLongIdentifierNameThatHasTonsOfLettersInIt
TOKEN_ASSIGN =
TOKEN_INTEGER 7
TOKEN_IDENTIFIER variable_names_may_contain_underscores_
TOKEN_IDENTIFIER _variables_can_start_with_an_underscore_67
TOKEN_INTEGER 7
TOKEN_IDENTIFIER minus5




===[HIDDEN TESTS/good14.bminor Input]===
main: function integer ( argc: integer, argv: array [] string ) =
{
}
boolFunction: function boolean(intVar:integer) =
{
	return intVar > 5;
}
intFunction: function integer(integer n) =
{
	total:integer = 0;
	int count;
	for(count = 0; count < n+1; count++)
	{
		total = total + count;
	
}


===[HIDDEN TESTS/good14.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good14.bminor Output]===
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_KEYWORD function
TOKEN_KEYWORD integer
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER argc
TOKEN_COLON :
TOKEN_KEYWORD integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER argv
TOKEN_COLON :
TOKEN_KEYWORD array
TOKEN_OPEN_BRACKET [
TOKEN_CLOSE_BRACKET ]
TOKEN_KEYWORD string
TOKEN_CLOSE_PARENS )
TOKEN_ASSIGN =
TOKEN_OPEN_BRACE {
TOKEN_CLOSE_BRACE }
TOKEN_IDENTIFIER boolFunction
TOKEN_COLON :
TOKEN_KEYWORD function
TOKEN_KEYWORD boolean
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER intVar
TOKEN_COLON :
TOKEN_KEYWORD integer
TOKEN_CLOSE_PARENS )
TOKEN_ASSIGN =
TOKEN_OPEN_BRACE {
TOKEN_KEYWORD return
TOKEN_IDENTIFIER intVar
TOKEN_GREATER >
TOKEN_INTEGER 5
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_IDENTIFIER intFunction
TOKEN_COLON :
TOKEN_KEYWORD function
TOKEN_KEYWORD integer
TOKEN_OPEN_PARENS (
TOKEN_KEYWORD integer
TOKEN_IDENTIFIER n
TOKEN_CLOSE_PARENS )
TOKEN_ASSIGN =
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER total
TOKEN_COLON :
TOKEN_KEYWORD integer
TOKEN_ASSIGN =
TOKEN_INTEGER 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER int
TOKEN_IDENTIFIER count
TOKEN_SEMICOLON ;
TOKEN_KEYWORD for
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER count
TOKEN_ASSIGN =
TOKEN_INTEGER 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER count
TOKEN_LESS <
TOKEN_IDENTIFIER n
TOKEN_INTEGER +1
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER count
TOKEN_INC ++
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER total
TOKEN_ASSIGN =
TOKEN_IDENTIFIER total
TOKEN_ADD +
TOKEN_IDENTIFIER count
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }




===[HIDDEN TESTS/good15.bminor Input]===
intFunction: function integer(intVar:integer, boolVar: boolean)
{
	if(boolVar)
	{
		intVar = intVar * 2;
	}
	return intVar;
}
// finds the largest value in the array
getLargest: function integer(intArrVar:array [] integer, int len) =
{
	largest:integer = 0;
	x:integer;
	for(x = 0; x < len; x++)
	{
		if(intArrVar[x] > largest)
		{
			largest = intArrVar[x];
		}
	}
	return largest;
		
}

main: function integer ( argc: integer, argv: array [] string ) =
{
	b:array [10] integer = {0,1,2,3,4,5};
	b[4] = 6;
	i:integer;
	z:integer = intFunction(i, true);
	print intArrFunction(v, z);
}

===[HIDDEN TESTS/good15.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good15.bminor Output]===
TOKEN_IDENTIFIER intFunction
TOKEN_COLON :
TOKEN_KEYWORD function
TOKEN_KEYWORD integer
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER intVar
TOKEN_COLON :
TOKEN_KEYWORD integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER boolVar
TOKEN_COLON :
TOKEN_KEYWORD boolean
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER boolVar
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER intVar
TOKEN_ASSIGN =
TOKEN_IDENTIFIER intVar
TOKEN_MULTIPLY *
TOKEN_INTEGER 2
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD return
TOKEN_IDENTIFIER intVar
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_COMMENT // finds the largest value in the array
TOKEN_IDENTIFIER getLargest
TOKEN_COLON :
TOKEN_KEYWORD function
TOKEN_KEYWORD integer
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER intArrVar
TOKEN_COLON :
TOKEN_KEYWORD array
TOKEN_OPEN_BRACKET [
TOKEN_CLOSE_BRACKET ]
TOKEN_KEYWORD integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER int
TOKEN_IDENTIFIER len
TOKEN_CLOSE_PARENS )
TOKEN_ASSIGN =
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER largest
TOKEN_COLON :
TOKEN_KEYWORD integer
TOKEN_ASSIGN =
TOKEN_INTEGER 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER x
TOKEN_COLON :
TOKEN_KEYWORD integer
TOKEN_SEMICOLON ;
TOKEN_KEYWORD for
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER x
TOKEN_ASSIGN =
TOKEN_INTEGER 0
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER x
TOKEN_LESS <
TOKEN_IDENTIFIER len
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER x
TOKEN_INC ++
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER intArrVar
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER x
TOKEN_CLOSE_BRACKET ]
TOKEN_GREATER >
TOKEN_IDENTIFIER largest
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER largest
TOKEN_ASSIGN =
TOKEN_IDENTIFIER intArrVar
TOKEN_OPEN_BRACKET [
TOKEN_IDENTIFIER x
TOKEN_CLOSE_BRACKET ]
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD return
TOKEN_IDENTIFIER largest
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_KEYWORD function
TOKEN_KEYWORD integer
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER argc
TOKEN_COLON :
TOKEN_KEYWORD integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER argv
TOKEN_COLON :
TOKEN_KEYWORD array
TOKEN_OPEN_BRACKET [
TOKEN_CLOSE_BRACKET ]
TOKEN_KEYWORD string
TOKEN_CLOSE_PARENS )
TOKEN_ASSIGN =
TOKEN_OPEN_BRACE {
TOKEN_IDENTIFIER b
TOKEN_COLON :
TOKEN_KEYWORD array
TOKEN_OPEN_BRACKET [
TOKEN_INTEGER 10
TOKEN_CLOSE_BRACKET ]
TOKEN_KEYWORD integer
TOKEN_ASSIGN =
TOKEN_OPEN_BRACE {
TOKEN_INTEGER 0
TOKEN_COMMA ,
TOKEN_INTEGER 1
TOKEN_COMMA ,
TOKEN_INTEGER 2
TOKEN_COMMA ,
TOKEN_INTEGER 3
TOKEN_COMMA ,
TOKEN_INTEGER 4
TOKEN_COMMA ,
TOKEN_INTEGER 5
TOKEN_CLOSE_BRACE }
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER b
TOKEN_OPEN_BRACKET [
TOKEN_INTEGER 4
TOKEN_CLOSE_BRACKET ]
TOKEN_ASSIGN =
TOKEN_INTEGER 6
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER i
TOKEN_COLON :
TOKEN_KEYWORD integer
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER z
TOKEN_COLON :
TOKEN_KEYWORD integer
TOKEN_ASSIGN =
TOKEN_IDENTIFIER intFunction
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER i
TOKEN_COMMA ,
TOKEN_IDENTIFIER true
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_KEYWORD print
TOKEN_IDENTIFIER intArrFunction
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER v
TOKEN_COMMA ,
TOKEN_IDENTIFIER z
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }




===[HIDDEN TESTS/good1.bminor Input]===
// Easy comment
/* Easy comment */

===[HIDDEN TESTS/good1.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good1.bminor Output]===
TOKEN_COMMENT // Easy comment
TOKEN_COMMENT /* Easy comment */




===[HIDDEN TESTS/good10.bminor Input]===
// Modulus operator
15%3

// Exponentiation operator
2^6

// Negation
-value

// Postincrement and postdecrement
number++;

number--;

===[HIDDEN TESTS/good10.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good10.bminor Output]===
TOKEN_COMMENT // Modulus operator
TOKEN_INTEGER 15
TOKEN_MOD %
TOKEN_INTEGER 3
TOKEN_COMMENT // Exponentiation operator
TOKEN_INTEGER 2
TOKEN_EXPONENT ^
TOKEN_INTEGER 6
TOKEN_COMMENT // Negation
TOKEN_SUBTRACT -
TOKEN_IDENTIFIER value
TOKEN_COMMENT // Postincrement and postdecrement
TOKEN_IDENTIFIER number
TOKEN_INC ++
TOKEN_SEMICOLON ;
TOKEN_IDENTIFIER number
TOKEN_DEC --
TOKEN_SEMICOLON ;




===[HIDDEN TESTS/good2.bminor Input]===
////* Harder comment ***/
/******************/
/*
This one works too.
*/
/***************
Also a good comment.
****************/
// comment // comment // comment


===[HIDDEN TESTS/good2.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good2.bminor Output]===
TOKEN_COMMENT ////* Harder comment ***/
TOKEN_COMMENT /******************/
TOKEN_COMMENT /*
This one works too.
*/
TOKEN_COMMENT /***************
Also a good comment.
****************/
TOKEN_COMMENT // comment // comment // comment




===[HIDDEN TESTS/good3.bminor Input]===
// Identifiers
CamelCase
lower_case
skiddo23
B4UFLY
i
x15


===[HIDDEN TESTS/good3.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good3.bminor Output]===
TOKEN_COMMENT // Identifiers
TOKEN_IDENTIFIER CamelCase
TOKEN_IDENTIFIER lower_case
TOKEN_IDENTIFIER skiddo23
TOKEN_IDENTIFIER B4UFLY
TOKEN_IDENTIFIER i
TOKEN_IDENTIFIER x15




===[HIDDEN TESTS/good4.bminor Input]===
// Equality Operators
== != <= < > >=

===[HIDDEN TESTS/good4.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good4.bminor Output]===
TOKEN_COMMENT // Equality Operators
TOKEN_EQUALITY ==
TOKEN_INEQUALITY !=
TOKEN_LE <=
TOKEN_LESS <
TOKEN_GREATER >
TOKEN_GE >=




===[HIDDEN TESTS/good5.bminor Input]===
// Various bits of punctuation
, : ; ( ) [ ] { }


===[HIDDEN TESTS/good5.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good5.bminor Output]===
TOKEN_COMMENT // Various bits of punctuation
TOKEN_COMMA ,
TOKEN_COLON :
TOKEN_SEMICOLON ;
TOKEN_OPEN_PARENS (
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACKET [
TOKEN_CLOSE_BRACKET ]
TOKEN_OPEN_BRACE {
TOKEN_CLOSE_BRACE }




===[HIDDEN TESTS/good6.bminor Input]===
// Complete function prototype
main: function integer ( argc: integer, argv: array [] string );


===[HIDDEN TESTS/good6.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good6.bminor Output]===
TOKEN_COMMENT // Complete function prototype
TOKEN_IDENTIFIER main
TOKEN_COLON :
TOKEN_KEYWORD function
TOKEN_KEYWORD integer
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER argc
TOKEN_COLON :
TOKEN_KEYWORD integer
TOKEN_COMMA ,
TOKEN_IDENTIFIER argv
TOKEN_COLON :
TOKEN_KEYWORD array
TOKEN_OPEN_BRACKET [
TOKEN_CLOSE_BRACKET ]
TOKEN_KEYWORD string
TOKEN_CLOSE_PARENS )
TOKEN_SEMICOLON ;




===[HIDDEN TESTS/good7.bminor Input]===
// Nested statements
if( x<15 ) {
    print "small";
} else {
    print "large!";
}


===[HIDDEN TESTS/good7.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good7.bminor Output]===
TOKEN_COMMENT // Nested statements
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER x
TOKEN_LESS <
TOKEN_INTEGER 15
TOKEN_CLOSE_PARENS )
TOKEN_OPEN_BRACE {
TOKEN_KEYWORD print
TOKEN_STRING small
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }
TOKEN_KEYWORD else
TOKEN_OPEN_BRACE {
TOKEN_KEYWORD print
TOKEN_STRING large!
TOKEN_SEMICOLON ;
TOKEN_CLOSE_BRACE }




===[HIDDEN TESTS/good8.bminor Input]===
// Valid integers
0
1024
-512
+256
// valid floats
1.2
0.45
.67
12e10
+1.2
-1.2
1.2e+1
1.2e-1
+1.2e+1
+1.2e-1
-1.2e+1
-1.2e-1

===[HIDDEN TESTS/good8.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good8.bminor Output]===
TOKEN_COMMENT // Valid integers
TOKEN_INTEGER 0
TOKEN_INTEGER 1024
TOKEN_INTEGER -512
TOKEN_INTEGER +256
TOKEN_COMMENT // valid floats
TOKEN_FLOAT 1.2
TOKEN_FLOAT 0.45
TOKEN_FLOAT .67
TOKEN_FLOAT 12e10
TOKEN_FLOAT +1.2
TOKEN_FLOAT -1.2
TOKEN_FLOAT 1.2
TOKEN_IDENTIFIER e
TOKEN_INTEGER +1
TOKEN_FLOAT 1.2
TOKEN_IDENTIFIER e
TOKEN_INTEGER -1
TOKEN_FLOAT +1.2
TOKEN_IDENTIFIER e
TOKEN_INTEGER +1
TOKEN_FLOAT +1.2
TOKEN_IDENTIFIER e
TOKEN_INTEGER -1
TOKEN_FLOAT -1.2
TOKEN_IDENTIFIER e
TOKEN_INTEGER +1
TOKEN_FLOAT -1.2
TOKEN_IDENTIFIER e
TOKEN_INTEGER -1




===[HIDDEN TESTS/good9.bminor Input]===
// Type Keywords
array
boolean
char
string
void
integer
float

===[HIDDEN TESTS/good9.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good9.bminor Output]===
TOKEN_COMMENT // Type Keywords
TOKEN_KEYWORD array
TOKEN_KEYWORD boolean
TOKEN_KEYWORD char
TOKEN_KEYWORD string
TOKEN_IDENTIFIER void
TOKEN_KEYWORD integer
TOKEN_KEYWORD float




====Bad Tests====
===[HIDDEN TESTS/bad11.bminor Input]===
/*
A string should not contain a literal newline,
but use backslash-n instead.
*/

"invalid

string"

===[HIDDEN TESTS/bad11.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad11.bminor Output]===
TOKEN_COMMENT /*
A string should not contain a literal newline,
but use backslash-n instead.
*/
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad12.bminor Input]===
'ca'

===[HIDDEN TESTS/bad12.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad12.bminor Output]===
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad13.bminor Input]===
''

===[HIDDEN TESTS/bad13.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad13.bminor Output]===
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad14.bminor Input]===
'\ac'

===[HIDDEN TESTS/bad14.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad14.bminor Output]===
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad15.bminor Input]===
'

===[HIDDEN TESTS/bad15.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad15.bminor Output]===
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad1.bminor Input]===
"unmatched string""

===[HIDDEN TESTS/bad1.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad1.bminor Output]===
TOKEN_STRING unmatched string
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad10.bminor Input]===
#compilers // No hashtags in B-minor

===[HIDDEN TESTS/bad10.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad10.bminor Output]===
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad2.bminor Input]===
"unterminated \"


===[HIDDEN TESTS/bad2.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad2.bminor Output]===
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad3.bminor Input]===
never started"






===[HIDDEN TESTS/bad3.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad3.bminor Output]===
TOKEN_IDENTIFIER never
TOKEN_IDENTIFIER started
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad4.bminor Input]===
'character?' // Character too long.

===[HIDDEN TESTS/bad4.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad4.bminor Output]===
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad5.bminor Input]===
'' // Empty character not allowed.

===[HIDDEN TESTS/bad5.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad5.bminor Output]===
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad6.bminor Input]===
~tilde // Invalid symbol

===[HIDDEN TESTS/bad6.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad6.bminor Output]===
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad7.bminor Input]===
/* Is this a valid comment */ @ */


===[HIDDEN TESTS/bad7.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad7.bminor Output]===
TOKEN_COMMENT /* Is this a valid comment */
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad8.bminor Input]===
"\0xGG" // invalid escape sequence

===[HIDDEN TESTS/bad8.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad8.bminor Output]===




===[HIDDEN TESTS/bad9.bminor Input]===
minus#44

===[HIDDEN TESTS/bad9.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad9.bminor Output]===
TOKEN_IDENTIFIER minus
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad16.bminor Input]===
@
#
&
|
\

===[HIDDEN TESTS/bad16.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad16.bminor Output]===
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad17.bminor Input]===
// unmatched comment throws error 
/* This is a comment.








===[HIDDEN TESTS/bad17.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad17.bminor Output]===
TOKEN_COMMENT // unmatched comment throws error 
TOKEN_DIVIDE /
TOKEN_MULTIPLY *
TOKEN_IDENTIFIER This
TOKEN_IDENTIFIER is
TOKEN_IDENTIFIER a
TOKEN_IDENTIFIER comment
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad18.bminor Input]===
// basic data types
" the quote is unmatched







===[HIDDEN TESTS/bad18.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad18.bminor Output]===
TOKEN_COMMENT // basic data types
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad19.bminor Input]===
// floating point mistake
5..6..0..5..0;

===[HIDDEN TESTS/bad19.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad19.bminor Output]===
TOKEN_COMMENT // floating point mistake
TOKEN_INTEGER 5
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad20.bminor Input]===
// test comparotors and boolean logic
if (a | b)
{
	print " a || b is true";
}
if (a & b)// must had 2 &&
{
	print " a || b is true";
}

===[HIDDEN TESTS/bad20.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad20.bminor Output]===
TOKEN_COMMENT // test comparotors and boolean logic
TOKEN_KEYWORD if
TOKEN_OPEN_PARENS (
TOKEN_IDENTIFIER a
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad21.bminor Input]===

"""


===[HIDDEN TESTS/bad21.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad21.bminor Output]===
TOKEN_STRING 
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad22.bminor Input]===
"012345678901234567890101234567890123456789010123456789012345678901012345678901234567890101234567890123456789010123456789012345678901012345678901234567890101234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890"


===[HIDDEN TESTS/bad22.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad22.bminor Output]===
ERROR: The input length is 345, which larger than 255 characters.




===[HIDDEN TESTS/bad23.bminor Input]===
$minus

===[HIDDEN TESTS/bad23.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad23.bminor Output]===
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad25.bminor Input]===
// invalid character
'😋'

===[HIDDEN TESTS/bad25.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad25.bminor Output]===
TOKEN_COMMENT // invalid character
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad26.bminor Input]===
/*
A string should not contain a literal newline,
but use backslash-n instead.
*/

"invalid

string"

===[HIDDEN TESTS/bad26.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad26.bminor Output]===
TOKEN_COMMENT /*
A string should not contain a literal newline,
but use backslash-n instead.
*/
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad27.bminor Input]===
'''

===[HIDDEN TESTS/bad27.bminor Status]===
return code: 0
TEST NOT PASSED

===[HIDDEN TESTS/bad27.bminor Output]===
TOKEN_CHAR '




===[HIDDEN TESTS/bad28.bminor Input]===
"'"'"

===[HIDDEN TESTS/bad28.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad28.bminor Output]===
TOKEN_STRING '
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad29.bminor Input]===
'\t\e\s\t\ \s\t\r\i\n\g'

===[HIDDEN TESTS/bad29.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad29.bminor Output]===
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad30.bminor Input]===
'\0x12\0x34'

===[HIDDEN TESTS/bad30.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad30.bminor Output]===
ERROR: Unrecognized token.



===[HIDDEN TESTS/bad0.bminor Input]===
!@#$*(!&%!@)#(@!+)!@*!@)*$!@_)(%!@_%(*!

===[HIDDEN TESTS/bad0.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad0.bminor Output]===
TOKEN_NOT !
ERROR: Unrecognized token.



===== SUMMARIZED SCANNER RESULTS =====
{
  "student_tests": {
    "Good": {
      "correct": 10,
      "incorrect": 0
    },
    "Bad": {
      "correct": 10,
      "incorrect": 0
    }
  },
  "hidden_tests": {
    "Good": {
      "correct": 15,
      "incorrect": 0
    },
    "Bad": {
      "correct": 28,
      "incorrect": 2
    }
  }
}
Scanner Project Grade
    ---------------------------------

    General Structure (35/35 points)
    ----------------------------------------------
    I like the goodies in bminor.c - token_name and the usage function are both really nice things to have

    Student Tests (20/20 points)
    ------------------------------------------
    Well rounded and reasonable test cases

    Hidden Tests (44/45 points)
    ------------------------------------------
    Unescaped single quotes in a character!

    Coding Style (10/10 points)
    ------------------------------------------
    I like how you spaced out the different sections in the flex file
